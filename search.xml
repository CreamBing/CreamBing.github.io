<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java编程思想第四版第九章读书笔记]]></title>
    <url>%2F2019%2F01%2F16%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E4%B9%9D%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的整理知识点，方便以后回顾，这一章主要讲解了java的接口 正文1.接口接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法 2.抽象类和抽象方法1public abstract void f(); 创建抽象类是希望通过这个通用接口操纵一系列类。如果一个类包含大于等于一个抽象方法，那么这个类就是抽象类，必须用abstract关键字来限定这个抽象类。如果试图直接创建该抽象类的对象，编译器会报错。如果抽象类的子类没有为基类的抽象方法提供定义，那么这个导出类依旧是抽象类。抽象类也可以不包含任何抽象方法，单纯的用abstract限定类。（该类不能产生对象）抽象类是很有用的重构工具，它可以使我们可以很容易的将公共方法沿着继承层次结构向上移动 3.接口interface这个关键字替代class关键字，产生了一个完全抽象的类。接口只提供形式，未提供任何具体实现。接口被用了建立类与类之间的协议。接口也可以包含域，但是这些域隐式的是static和final的。因此，其中定义的成员变量，是static&amp;final的。implenments关键字可以跟一组接口，extends关键字只能跟一个基类。接口中的方法必须是public的，隐式的被声明public的，如果要显示声明，它们也必须被声明为public的。否则在继承的过程中，可访问权限被降低，这是java编译器所不允许的。 4.完全解耦策略设计模式：创建一个能够根据传递参数对象不同而具有不同行为的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344package interfaces.classprocessor;import java.util.*;import static net.mindview.util.Print.*;class Processor &#123;public String name() &#123;return getClass().getSimpleName();&#125;Object process(Object input) &#123; return input; &#125;&#125;class Upcase extends Processor &#123;String process(Object input) &#123; // Covariant returnreturn ((String)input).toUpperCase();&#125;&#125;class Downcase extends Processor &#123;String process(Object input) &#123;return ((String)input).toLowerCase();&#125;&#125;class Splitter extends Processor &#123;String process(Object input) &#123;// The split() argument divides a String into pieces:return Arrays.toString(((String)input).split(" "));&#125;&#125;public class Apply &#123;public static void process(Processor p, Object s) &#123;print("Using Processor " + p.name());print(p.process(s));&#125;public static String s ="Disagreement with beliefs is by definition incorrect";public static void main(String[] args) &#123;process(new Upcase(), s);process(new Downcase(), s);process(new Splitter(), s);&#125;&#125; /* Output:Using Processor UpcaseDISAGREEMENT WITH BELIEFS IS BY DEFINITION INCORRECTUsing Processor Downcasedisagreement with beliefs is by definition incorrectUsing Processor Splitter[Disagreement, with, beliefs, is, by, definition, incorrect] 适配器设计模式:当一个类是第三方jar中，你无法修改，但是你想用这个类实现某些接口，可以利用适配器模式，新建一个类实现接口，并将不可修改的类作为它的属性，利用这个属性的方法来实现接口，调用的时候在外面包一层1234567891011121314151617181920212223242526272829303132333435363738394041424344/* Solution includes, in same package:* package interfaces.interfaceprocessor;* public class StringMixer &#123;* static String process(String s) &#123;* char[] ca = new char[s.length()];* if((s.length())%2 == 0) &#123;* for(int i = 0; i &lt; s.length(); i += 2) &#123;* ca[i] = s.charAt(i + 1);* ca[i + 1] = s.charAt(i); * &#125; * return new String(ca);* &#125;* else &#123;* for(int i = 0; i &lt; s.length() - 1; i += 2) &#123;* ca[i] = s.charAt(i + 1);* ca[i + 1] = s.charAt(i); * &#125;* ca[s.length() - 1] = s.charAt(s.length() - 1); * return new String(ca);* &#125;* &#125; * &#125;*/// program takes command line String argument:package interfaces.interfaceprocessor;class StringMixerAdapter implements Processor &#123; public String name() &#123; return "StringMixerAdapter"; &#125; StringMixer stringMixer; public StringMixerAdapter(StringMixer stringMixer) &#123; this.stringMixer = stringMixer; &#125; public String process(Object input) &#123; return stringMixer.process((String)input); &#125; &#125;public class StringMixerProcessor &#123; public static void main(String[] args) &#123; String s = new String(args[0]); Apply.process(new StringMixerAdapter(new StringMixer()), s); &#125;&#125; 5.java中的多重继承java没有任何与接口相关的存储，因此可以实现继承多个接口使用接口的核心原因：1.为了能够向上转型为多个基本类型 2.顺带可以防止客户端程序员创建该类的对象，确保这是一个接口java通过接口和内部类来达到多重继承的效果 6.通过继承扩展接口extends只能用于单一类，但是接口继承时却可以引用多个接口，用逗号分开。1interface Interface1 extends Interface2，Interface3&#123;&#125; 接口无法用implements来实现别的接口，必须用extends。应该尽量避免组合的多个接口中包含相同方法名，这样会造成代码可读性的混乱。 7.适配接口类的构造器接受一个接口，将希望使用该类的类都实现该接口，这样可以类就可以作用于更多的类型。比如Scanner类，想使用该类的类型和策略模式的不同：方法可以作用于不同的类型。而适配器模式是，将接口作为类的构造器参数，子类传入这个类，就能调用这个类的方法 8、接口中的域接口中的域是static&amp;final的，所以常量初始化值会用大写字母的风格。package interfaces;public interface Months {intJANUARY = 1, FEBRUARY = 2, MARCH = 3,APRIL = 4, MAY = 5, JUNE = 6, JULY = 7,AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,NOVEMBER = 11, DECEMBER = 12;} 但是一般不这么做，在接口中定义常量，而是用enum关键字实现。接口中定义的常量一定要初始化，不能出现空final，但是可以被非常量表达式初始化。 9.嵌套接口嵌套在另一个接口中的接口自动是 public 的，而不能声明为 private 的.嵌套在另一个类中的接口可以是 private 的，可以在内部实现成为一个 public 类，但是这个类不允许向上转型当实现某个接口是，并不需要实现嵌套在其内部的任何借口，而且，private接口不能在定义它的类之外被实现。 10.接口与工厂工厂设计模式：在工厂对象上调用创建方法，该工厂对象将生成接口的某个实现对象。这样将代码与接口实现分离，这样使得我们可以透明的将某个实现替换成另一个实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344import static net.mindview.util.Print.*;interface Service &#123;void method1();void method2();&#125;interface ServiceFactory &#123;Service getService();&#125;class Implementation1 implements Service &#123;Implementation1() &#123;&#125; // Package accesspublic void method1() &#123;print("Implementation1 method1");&#125;public void method2() &#123;print("Implementation1 method2");&#125;&#125;class Implementation1Factory implements ServiceFactory &#123;public Service getService() &#123;return new Implementation1();&#125;&#125;class Implementation2 implements Service &#123;Implementation2() &#123;&#125; // Package accesspublic void method1() &#123;print("Implementation2 method1");&#125;public void method2() &#123;print("Implementation2 method2");&#125;&#125;class Implementation2Factory implements ServiceFactory &#123;public Service getService() &#123;return new Implementation2();&#125;&#125;public class Factories &#123;public static void serviceConsumer(ServiceFactory fact) &#123;Service s = fact.getService();s.method1();s.method2();&#125;public static void main(String[] args) &#123;serviceConsumer(new Implementation1Factory());// Implementations are completely interchangeable:serviceConsumer(new Implementation2Factory());&#125;&#125; /* Output:Implementation1 method1Implementation1 method2Implementation2 method1Implementation2 method2 对消费者传递一个工厂1对象，产生工厂1的产品，调用产品1的方法。对消费者传递一个工厂2对象，产生工厂2的产品，调用产品2的方法。 总结： 确定接口是理想选择，因而应该总是选择接口而不是具体的类,对于创建类，几乎在任何时刻，都可以替代为创建一个工厂和一个接口 这其实是一种陷阱，变成了一种草率的设计优化，任何抽象性应该是真正的需求而产生的 参考资料https://blog.csdn.net/severusyue/article/details/51766573 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第八章读书笔记]]></title>
    <url>%2F2019%2F01%2F16%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的整理知识点，方便以后回顾，这一章主要讲解了java的多态 正文1.多态在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征“封装”通过合并特征和行为来创建新的数据类型。（合并成员函数和方法创建类）“多态”消除类型之间的耦合关系多态也称做动态绑定，后期绑定或运行时绑定 2.在论向上转型子类对象的引用向上转型为基类，传递到相应方法中 3.转机将一个方法调用同一个方法主体关联起来被称作绑定。程序执行前的绑定（由编译器和连接程序实现），称为前期绑定。运行时根据对象的类型进行绑定，称为后期绑定，也称为动态绑定或运行时绑定。Java中除了static方法和final方法（private属于final方法）外，其它所有方法都是动态绑定。多态让程序员将“改变的事物与未改变的事物分离开来注意:只有非private方法才能被覆盖，当然覆盖private类时，编译器不会报错。但是导出类和基类中的该同名方法，是两个不同的方法，向上转型为基类调用时，会调用基类的那个private的方法静态方法是与类，而非单个对象关联的，因此不是多态的任何域访问操作都有编译器解析，因此不是多态的当Sub对象转型为Super使用时，任何域访问操作都将由编译器解析，因此不是多态的。（在包含相同成员变量时，子类包含两个域，基类和自己的，当要调用基类中该重名成员变量时，系统不会多态的自动的调用基类的该变量，需要显式的指明super.成员变量。） 4.构造器和多态当有多重继承关系时，调用构造器顺序：基类构造器 -&gt; 成员的初始化方法 -&gt; 子类构造器完整:基类staitic–&gt;子类static–&gt;基类基本类型设为默认值0，对象引用被设为Null–&gt;基类构造器–&gt;子类基本类型设为默认值0，对象引用被设为Null–&gt;子类构造器在销毁时，需要显式的调用基类的dispose()方法，销毁的顺序和初始化相反，包括字段的销毁顺序和申明的顺序相反。共享数据最后dispose()。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. */package com.creambing.thinkinginjava.polymorphism;/** * Class Name: Share * Description: 清理，用来记录引用计数 * * author: CreamBing * time: 2019-01-11 14:32 * version: v1.0.0 */public class Share &#123; private int refcount = 0; private static long counter = 0; private final long id = ++counter; public Share() &#123; System.out.println("create"+this); &#125; public void addRef()&#123; refcount++; &#125; public int getRefcount() &#123; return refcount; &#125; protected void dispose()&#123; if(--refcount==0)&#123; System.out.println("dispose"+this); &#125; &#125; @Override public String toString() &#123; return "Share&#123;" + "refcount=" + refcount + ", id=" + id + '&#125;'; &#125; public static void main(String[] args) &#123; Share s1 = new Share(); Share s2 = new Share(); System.out.println("**********"); System.out.println(s1); System.out.println("************"); System.out.println(s2); &#125;&#125;/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. *///package com.creambing.thinkinginjava.polymorphism;/** * Class Name: Composing * Description: 共享类 * * author: CreamBing * time: 2019-01-11 14:42 * version: v1.0.0 */public class Composing &#123; private Share share; private static long count = 0; private final long id = ++count; public Composing(Share share) &#123; this.share = share; this.share.addRef(); System.out.println("create "+this); &#125; protected void dispose()&#123; System.out.println("dispose "+this); share.dispose(); &#125; @Override public String toString() &#123; return "Composing&#123;" + "share=" + share + ", id=" + id + '&#125;'; &#125;&#125;/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. *///package com.creambing.thinkinginjava.polymorphism;/** * Class Name: ReferenceCounting * Description: 对象引用计数 * &lt;p&gt; * author: CreamBing * time: 2019-01-11 14:48 * version: v1.0.0 */public class ReferenceCounting &#123; Share s1 = new Share(); Composing[] ca; public ReferenceCounting() &#123; this.ca = new Composing[]&#123;new Composing(s1), new Composing(s1), new Composing(s1)&#125;; &#125; @Override protected void finalize() throws Throwable &#123; if (s1.getRefcount() != 0) &#123; System.out.println("Composing没有清理干净，还有实例引用Share"); &#125; else &#123; System.out.println("Composing清理干净，开始垃圾回收"); super.finalize(); &#125; &#125; /** * createShare&#123;refcount=0, id=1&#125; * create Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=1&#125; * create Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * create Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=3&#125; * dispose Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=1&#125; * c[0] dispose * 开始强制垃圾回收 * ************************************* * dispose Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * dispose Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=3&#125; * disposeShare&#123;refcount=0, id=1&#125; * ca[1],ca[2]清理，所有Composing对象清理完毕 * 开始强制垃圾回收 * Composing清理干净，开始垃圾回收 * 注释掉********************************后面的东西 * createShare&#123;refcount=0, id=1&#125; * create Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=1&#125; * create Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * create Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=3&#125; * dispose Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=1&#125; * c[0] dispose * 开始强制垃圾回收 * ************************************* * Composing没有清理干净，还有实例引用Share * @param args */ public static void main(String[] args) &#123; ReferenceCounting r = new ReferenceCounting(); r.ca[0].dispose(); System.out.println("c[0] dispose"); System.out.println("开始强制垃圾回收"); System.runFinalizersOnExit(true); System.out.println("*************************************"); r.ca[1].dispose(); r.ca[2].dispose(); System.out.println("ca[1],ca[2]清理，所有Composing对象清理完毕"); System.out.println("开始强制垃圾回收"); System.runFinalizersOnExit(true); &#125;&#125; 上面Share类中的下列代码实现了引用计数,refcount记录其他类中对这个类对象的引用数，id记录这是这个类的第几个实例，counter记录了这个类工实例的几次不过下面的实现虽然巧妙但是并不完美，因为counter的值还是可以通过反射进行修改，详情可见EffectiveJava第三版第一条读书笔记123private int refcount = 0;private static long counter = 0;private final long id = ++counter; 构造器内部的多态方法的行为：在初始化时，基类构造器中调用子类中覆盖的方法，此时子类的成员变量未赋值，如果此时对其操作可能会产生意想之外的结果。所以应该避免这样做。在构造器内唯一能够安全调用的事基类中的final方法。 编写构造器时一条有效的准则:用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其它方法 5.协变返回类型子类中被覆盖的方法可以返回基类方法所返回类型的子类，这样虽然返回值类型不同，但是也算覆盖。 6.用继承进行设计组合更加灵活，首选组合用继承表达行为间的差异，用字段表达状态上的变化 状态设计模式创建一个基类的引用，通过方法改变其所指向的对象类型（子类们），调用相同的方法，行为产生变化。（调用了相应子类的方法）。 这样可以实现动态灵活性。如下所示：12345678910111213141516171819202122232425import static net.mindview.util.Print.*;class Actor &#123;public void act() &#123;&#125;&#125;class HappyActor extends Actor &#123;public void act() &#123; print("HappyActor"); &#125;&#125;class SadActor extends Actor &#123;public void act() &#123; print("SadActor"); &#125;&#125;class Stage &#123;private Actor actor = new HappyActor();public void change() &#123; actor = new SadActor(); &#125;public void performPlay() &#123; actor.act(); &#125;&#125;public class Transmogrify &#123;public static void main(String[] args) &#123;Stage stage = new Stage();stage.performPlay();stage.change();stage.performPlay();&#125;&#125; /* Output:HappyActorSadActor 对于子类扩展基类接口的情况，向上转型后不能调用子类的不同于基类的新方法。这样需要用到向下转型，在Java中，所有的转型都会对其进行检查。称为“运行时类型识别”（RTTT）如果转型正确，则转型成功；如果所转类型不是正确的类型，则转型失败，返回ClassCastException异常。父类引用可以指向子类对象，子类引用不可以指向父类对象12345678910111213141516171819202122232425class Useful &#123;public void f() &#123;&#125;public void g() &#123;&#125;&#125;class MoreUseful extends Useful &#123;public void f() &#123;&#125;public void g() &#123;&#125;public void u() &#123;&#125;public void v() &#123;&#125;public void w() &#123;&#125;&#125;public class RTTI &#123;public static void main(String[] args) &#123;Useful[] x = &#123;new Useful(),new MoreUseful()&#125;;x[0].f();x[1].g();// Compile time: method not found in Useful://! x[1].u();((MoreUseful)x[1]).u(); // Downcast/RTTI((MoreUseful)x[0]).u(); // Exception thrown&#125;&#125; 参考资料https://blog.csdn.net/severusyue/article/details/51721940 Java编程思想第四版读书笔记——第八章 多态 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveJava第三版第二条读书笔记]]></title>
    <url>%2F2019%2F01%2F14%2FEffectiveJava%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%AC%E4%BA%8C%E6%9D%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言自己java编程已有两年，自己也写过一些轮子，也在工作中针对自己以前写的代码重构过，但是距离那些优秀的类库总有一些差距，最近在看 Effective Java 第三版，书中总结甚为精辟，遂在阅读过程中逐条写下笔记，以指导自己更加有效的使用 java 编程语言及基本类库,涵盖部分jdk 7,8,9 的新特性 目的 遇到多个构造器参数时要考虑使用构建器 正文例:用一个类表示包装食品外面显示的营养成分标签，其中有几个域是必须的当有一个类需要多个参数的构造器，我们一般最开始考虑到的是重叠构造器1234567891011121314151617181920212223242526272829303132333435363738394041424344// Telescoping constructor pattern - does not scale well! (Pages 10-11)不能很好的扩展public class NutritionFacts &#123; private final int servingSize; // (mL) required private final int servings; // (per container) required private final int calories; // (per serving) optional private final int fat; // (g/serving) optional private final int sodium; // (mg/serving) optional private final int carbohydrate; // (g/serving) optional public NutritionFacts(int servingSize, int servings) &#123; this(servingSize, servings, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories) &#123; this(servingSize, servings, calories, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat) &#123; this(servingSize, servings, calories, fat, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) &#123; this(servingSize, servings, calories, fat, sodium, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) &#123; this.servingSize = servingSize; this.servings = servings; this.calories = calories; this.fat = fat; this.sodium = sodium; this.carbohydrate = carbohydrate; &#125; public static void main(String[] args) &#123; //servingSize，servings,calories,fat,sodium,carbohydrate NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27); &#125; &#125; 如上面 main 方法中的调用方法所示：假设我们需要设置 sodium 和 carbohydrate 的值，但是我们不想要设置 fat 的值，如上所见，所调用的构造器需要我们设置我们不想设置的参数，除非我们在编写一个构造器，内部用 set 方法初始化. 重叠构造器在有很多参数的时候，客户端代码会很难编写并且难以阅读，另外其本身也不能很好的扩展 那我们现在考虑更为普遍的一种方式: JavaBeans12345678910111213141516171819202122232425262728// JavaBeans Pattern - allows inconsistency, mandates mutability (pages 11-12)允许不一致，强制要求可变性public class NutritionFacts &#123; // Parameters initialized to default values (if any) private int servingSize = -1; // Required; no default value private int servings = -1; // Required; no default value private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts() &#123; &#125; // Setters public void setServingSize(int val) &#123; servingSize = val; &#125; public void setServings(int val) &#123; servings = val; &#125; public void setCalories(int val) &#123; calories = val; &#125; public void setFat(int val) &#123; fat = val; &#125; public void setSodium(int val) &#123; sodium = val; &#125; public void setCarbohydrate(int val) &#123; carbohydrate = val; &#125; public static void main(String[] args) &#123; NutritionFacts cocaCola = new NutritionFacts(); cocaCola.setServingSize(240); cocaCola.setServings(8); cocaCola.setCalories(100); cocaCola.setSodium(35); cocaCola.setCarbohydrate(27); &#125;&#125; JavaBeans 方法的缺点：12由于 JavaBeans 方式将构造过程分隔到了几个调用过程中，在构造过程中 JavaBeans 可能处于不一致的状态，无法仅仅通过检查构造器参数的有效性在保证一致性JavaBeans 模式使得把类做成不可变的可能性不复存在，也就是说可能存在线程安全问题 那么这里我们扩展一下 SpringMVC 中的单例模式，我们知道 controller -&gt; service -&gt; dao 这个流程，他们的对象都是单例的，想想一下这些单例的对象在处理我们传给后台的实体 bean 时会不会有问题了？如果一个张三带着正确密码在登陆的同时，一个李四在登陆，如果是单例并且状态可变，那么最后校验是张三和李四的密码导致他登陆失败？答：是不会有问题的，因为我们的实体bean是前台的json串反序列化，或者我们自己 new,然后拼装起来的，所以他并不是单例模式。另外这也说明单例模式中存在可变域可能导致线程不安全，因此 1.在 controller 类中不要定义非单例成员变量 2.万一必须要定义一个非静态成员变量时候，则通过注解@Scope(“prototype”)，将其设置为多例模式另外上网查了下(未验证)了 JavaBeans 的反序列化的三种工具：fastJson JackJson 以及 Gson 123Gson是通过反射遍历该类中的所有属性，并把其值序列化成json三个工具类的序列化结果跟类的set方法没有关系。JackJson和FastJson序列化结果跟get方法有关系 第三种方法就是建造者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class NutritionFacts &#123; //必须域 private final int servingSize; //必须域 private final int servings; //卡路里 private final int calories; //脂肪 private final int fat; //钠 private final int sodium; //糖类 private final int carbohydrate; public static class Builder &#123; // Required parameters private final int servingSize; private final int servings; // Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; //必须参数通过唯一构造器初始化 public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val) &#123; calories = val; return this; &#125; public Builder fat(int val) &#123; fat = val; return this; &#125; public Builder sodium(int val) &#123; sodium = val; return this; &#125; public Builder carbohydrate(int val) &#123; carbohydrate = val; return this; &#125; public NutritionFacts build() &#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder) &#123; servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; &#125; public static void main(String[] args) &#123; NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build(); &#125;&#125; 从上面的链式调用可以发现，这样做确实比较优雅，但是他开销比较大。由于上面的这个建造器的属性都设置的final,所以在建造后就无法在修改了？这里有几个疑问？1.建造器模式是否只是应用于不可变类？2.假设我们要对建造器模式类中的一个属性值在建造后重新赋值，我们怎么做？将 final 去掉，提供 setter 方法吗？如果这样，它和静态内部类中的对应属性是否就不一致了，而且 api 混乱，导致初始化域的方法有两个？3.建造器模式的序列化和反序列化？还是上一个问题，静态内部类的属性和建造器内的属性是否需要保持一致，如果是利用 fastjson 的话，内部和外部都得提供 getter 方法，如此种种，感觉建造器模式还是适合工具类，不太适合 web 中的 javabeans,比如表单。尽管可能提供多个参数的构造方法4.由建造器模式的链式调用想到 JavaBeans 的 setter 方法为什么不return this了，这样就可以链式调用了？ 比如 guava 中 Ordering 的链式调用123456789101112131415161718192021222324252627282930313233343536373839/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.creambing;import com.google.common.collect.Ordering;import org.junit.Assert;import org.junit.Test;import java.util.Arrays;import java.util.Collections;import java.util.List;import static org.hamcrest.core.IsEqual.equalTo;/** * Class Name:BuilderModeTest * Description:建造者模式测试 * * @author Bing * @create 2019-01-14 16:05 * @version v1.0 */public class BuilderModeTest &#123; /** * 将空值放置在最前面的情况 */ @Test public void testOrderNaturalByNullFirst() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 5, null, 3, 8, 2); Collections.sort(list, Ordering.natural().nullsFirst()); System.out.println("空在最前面-排序后" + list.toString()); Assert.assertThat(list.toString(),equalTo("[null, 1, 2, 3, 5, 8]")); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536类的定义public abstract class Ordering&lt;T&gt; implements Comparator&lt;T&gt; &#123;&#125;@GwtCompatible( serializable = true)final class NaturalOrdering extends Ordering&lt;Comparable&gt; implements Serializable &#123;&#125;@GwtCompatible( serializable = true)final class NullsFirstOrdering&lt;T&gt; extends Ordering&lt;T&gt; implements Serializable &#123;&#125;Ordering抽象类中的静态方法，返回他的子类NaturalOrdering的一个实例，这是个饿汉式不可变单例@GwtCompatible( serializable = true ) public static &lt;C extends Comparable&gt; Ordering&lt;C&gt; natural() &#123; return NaturalOrdering.INSTANCE; &#125;NaturalOrdering中的成员变量static final NaturalOrdering INSTANCE = new NaturalOrdering();Ordering抽象类中的一个公共方法@GwtCompatible( serializable = true ) public &lt;S extends T&gt; Ordering&lt;S&gt; nullsFirst() &#123; return new NullsFirstOrdering(this); &#125;NaturalOrdering中的重写了public &lt;S extends Comparable&gt; Ordering&lt;S&gt; nullsFirst() &#123; Ordering&lt;Comparable&gt; result = this.nullsFirst; if (result == null) &#123; result = this.nullsFirst = super.nullsFirst(); &#125; return result; &#125; 从上可以看到跟构造器关系不大，更符合第一点，用静态工厂方法代替构造器，基于接口编程，初始化返回其子类对象,接着在调基类接口方法 参考资料]]></content>
  </entry>
  <entry>
    <title><![CDATA[EffectiveJava第三版第一条读书笔记]]></title>
    <url>%2F2019%2F01%2F14%2FEffectiveJava%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言自己java编程已有两年，自己也写过一些轮子，也在工作中针对自己以前写的代码重构过，但是距离那些优秀的类库总有一些差距，最近在看 Effective Java 第三版，书中总结甚为精辟，遂在阅读过程中逐条写下笔记，以指导自己更加有效的使用 java 编程语言及基本类库,涵盖部分jdk 7,8,9 的新特性 目的 用静态工厂方法代替构造器 正文思考对于类而言，为了让客户端获取它自身的一个实例，最传统的方法就是提供一个公有的构造器，但同时，你是否应该考虑提供一个公有的静态工厂方法，来返回此类的实例的静态方法? 提供静态工厂方法的优势12345* 它们有名字,比起构造方法的不同参数列表，静态工厂方法能提供有含义且带有参数的初始化方法* 不用每次被调用时都创建新对象，例如单例模式* 可以返回原返回类型的子类，设计模式中的基本的原则之一—— 『里氏替换』 原则，就是说子类应该能替换父类。这项技术用于基于接口的框架，例如Collections Framework API* 返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。例如EnumSet* 方法返回的对象所属的类，在编写包含该静态工厂方法的类时，可以不存在，构成了服务提供者框架(Service Provider Framework)例如 JDBC API 我们现在对每条优点来实践一下1.它们有名字假设我们有一个苹果类 (Appale.java) 它有三个属性:颜色(color)，重量(weight)和是否好吃(delicious)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.creambing.effectivejava;/** * Class Name:Apple * Description:静态工厂代替构造器 * * @author Bing * @create 2019-01-14 11:32 * @version v1.0 */public class Apple &#123; //设为final表示一旦建造成功不许修改 //这里不能设为final,因为final定义的要不在定义时候初始化，要不在构造器初始化 private Color color; private int weight;//单位为g private boolean delicious;//是否好吃 true:好吃，false:不好吃 private Apple() &#123; &#125; //作为例子讲解，本应注释掉 public Apple(Color color, int weight) &#123; this.color = color; this.weight = weight; &#125; //作为例子讲解，本应注释掉 public Apple(Color color, int weight, boolean delicious) &#123; this.color = color; this.weight = weight; this.delicious = delicious; &#125; public Color getColor() &#123; return color; &#125; public void setColor(Color color) &#123; this.color = color; &#125; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; public boolean isDelicious() &#123; return delicious; &#125; public void setDelicious(boolean delicious) &#123; this.delicious = delicious; &#125; //**********上面的是一个标准的 javabeans 除了将无参构造器设置为私有的********************************************* public static Apple newInstance()&#123; return new Apple(); &#125; public static Apple createRedDelicious()&#123; return Apple.newInstance().withColor(Color.RED).withDelicious(Boolean.TRUE); &#125; public static Apple createRedNoDelicious()&#123; return Apple.newInstance().withColor(Color.RED).withDelicious(Boolean.FALSE); &#125; //********************上面提供了三个静态工厂方法，很明显意义更加明确而且用户不会调用出错，封装性更好****************** //那这个跟set方法没什么区别了 public Apple withColor(Color c)&#123; this.color = c; return this; &#125; public Apple withWeight(int w)&#123; this.weight = w; return this; &#125; public Apple withDelicious(Boolean b)&#123; this.delicious = b; return this; &#125; //*******************为了不破坏 javabeans 规范，又达到链式调用的目的，新增的一系列 withxxx() 方法****************** @Override public String toString() &#123; return "Apple&#123;" + "color=" + color + ", weight=" + weight + '&#125;'; &#125; public enum Color&#123; RED,GREEN &#125; public static void main(String[] args) &#123; //设置一个5克的绿色苹果 Apple a = Apple.newInstance().withColor(Color.GREEN).withWeight(5); System.out.println(a); //设置一个好吃的红苹果,直接将好吃和不好吃封装到了api里面，通过函数名字表示，用户就很难调用错误的方法 Apple a1 = Apple.createRedDelicious(); //我不得不传一个重量的参数，虽然 0g 的红苹果现实没意义，但是如果是其它可选参数了，另外第三个参数我们也有可能写错，到底是ture好吃，还是false好吃，我们不得不去看api Apple a2 = new Apple(Color.RED,0,Boolean.TRUE); &#125;&#125; 类中的注释很好的说明了问题，另外调用时候的意义也更加明确1234//设置一个好吃的红苹果,直接将好吃和不好吃封装到了api里面，通过函数名字表示，用户就很难调用错误的方法Apple a1 = Apple.createRedDelicious();//我不得不传一个重量的参数，虽然 0g 的红苹果现实没意义，但是如果是其它可选参数了，另外第三个参数我们也有可能写错，到底是ture好吃，还是false好吃，我们不得不去看apiApple a2 = new Apple(Color.RED,0,Boolean.TRUE); 2.单例模式这里可以看一下之前在读java编程思想-类的访问权限的时候所做的笔记:java编程思想第四版第六章读书笔记3.基于接口的框架例如 jdk 中 java.util.Collections.java 类其中的很多方法就是返回类型是一个接口，其真正返回的是它的子类对象123public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) &#123; return new UnmodifiableCollection&lt;&gt;(c); &#125; 扩展:https://blog.csdn.net/cilen/article/details/7744969 Collections.unmodifiableList方法的使用与场景4.返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值例如 jdk 中 EnumSet 的noneOf方法123456789public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123; Enum&lt;?&gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + &quot; not an enum&quot;); if (universe.length &lt;= 64) return new RegularEnumSet&lt;&gt;(elementType, universe); else return new JumboEnumSet&lt;&gt;(elementType, universe);&#125; 5.方法返回的对象所属的类，在编写包含该静态工厂方法的类时，可以不存在，构成了服务提供者框架(Service Provider Framework)例如 JDBC APITODO:等我看了相关api再来记录 提供静态工厂方法的缺点12* .类如果不含有公有的或者受保护的构造器，就不能被子类化* .程序员很难发现它们 常用静态工厂方法的取名1234567891011* from: 类型转化方法 * of: 聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来 * valueOf：该方法返回的实例与它的参数具有相同的 “值” 。 * getType：返回的类型是根据方法的参数来描述的，但是不能够说与参数具有相同的值。就像是针对类型的getInstance，但是在工厂方法处于不同的类中的时候使用 * newType：像newInstance一样，但是在工厂方法处于不同的类中的时候使用 * type: getType和newType的简版 * instance 或者 getInstance: 返回的实例是根据方法的参数来描述的，但是不能够说与参数具有相同的值。一般用来表示获取相同的实例，如单例模式，或根根参数获取不同的单例等。 * create 或者 newInstance：类似于getInstance。不同的是，一般用来表示获取新的实例，如Class#newInstance()方法等 * Class#newInstance()破坏了编译时的检查： * newInstance方法总是企图调用类的无参构造器。这个构造器甚至可能根本不存在，或者用户无访问权限，但编译期间你不会收到任何错误 * newInstance方法还会传播由无参构造器抛出的任何异常，即使newInstance缺乏相应的throws子句 梨子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. */package com.creambing.effectivejava3;import com.google.common.collect.Maps;import java.util.EnumSet;import java.util.HashMap;import java.util.Map;/** * Class Name: StaticFactory * Description: 考虑用静态工厂方法代替构造器 * 优势: * 它们有名字,比起构造方法的不同参数列表，静态工厂方法能提供有含义且带有参数的初始化方法 * 不用每次被调用时都创建新对象，例如单例模式 * 可以返回原返回类型的子类，设计模式中的基本的原则之一—— 『里氏替换』 原则，就是说子类应该能替换父类。这项技术用于基于接口的框架，例如Collections Framework API * 返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。例如EnumSet * 方法返回的对象所属的类，在编写包含该静态工厂方法的类时，可以不存在，构成了服务提供者框架(Service Provider Framework)例如 JDBC API * *缺点 * 1.类如果不含有公有的或者受保护的构造器，就不能被子类化 * 2.程序员很难发现它们 * * 静态工厂方法惯用名称： * from: 类型转化方法 * of: 聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来 * valueOf：该方法返回的实例与它的参数具有相同的 “值” 。 * getType：返回的类型是根据方法的参数来描述的，但是不能够说与参数具有相同的值。就像是针对类型的getInstance，但是在工厂方法处于不同的类中的时候使用 * newType：像newInstance一样，但是在工厂方法处于不同的类中的时候使用 * type: getType和newType的简版 * instance 或者 getInstance: 返回的实例是根据方法的参数来描述的，但是不能够说与参数具有相同的值。一般用来表示获取相同的实例，如单例模式，或根根参数获取不同的单例等。 * create 或者 newInstance：类似于getInstance。不同的是，一般用来表示获取新的实例，如Class#newInstance()方法等 * Class#newInstance()破坏了编译时的检查： * newInstance方法总是企图调用类的无参构造器。这个构造器甚至可能根本不存在，或者用户无访问权限，但编译期间你不会收到任何错误 * newInstance方法还会传播由无参构造器抛出的任何异常，即使newInstance缺乏相应的throws子句 * * author: CreamBing * time: 2019-01-13 14:53 * version: v1.0.0 */public class StaticFactory &#123; /** * 需要引入依赖 * &lt;dependency&gt; * &lt;groupId&gt;com.google.guava&lt;/groupId&gt; * &lt;artifactId&gt;guava&lt;/artifactId&gt; * &lt;version&gt;27.0.1-jre&lt;/version&gt; * &lt;/dependency&gt; * @param args */ public static void main(String[] args) &#123; //不过自从 java7 开始,由于泛型参数是可以被推导出，所以可以在创建实例时省略掉泛型参数。 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); //google guava类库 我们来看看别人类库是怎么封装的 /* public static &lt;K, V&gt; HashMap&lt;K, V&gt; newHashMap() &#123; return new HashMap(); &#125; */ Map&lt;String,String&gt; map1 = Maps.newHashMap(); /* * public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123; Enum&lt;?&gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + " not an enum"); if (universe.length &lt;= 64) return new RegularEnumSet&lt;&gt;(elementType, universe); else return new JumboEnumSet&lt;&gt;(elementType, universe); &#125; * */ //jdk8内部实现,它返回两种子类之一的一个实例，取决于传入枚举类型的大小 EnumSet&lt;Season&gt; enumSet = EnumSet.of(Season.SUMMER, Season.WINTER); &#125; enum Season &#123; SPRING, SUMMER, FALL, WINTER &#125;&#125; 参考资料https://blog.csdn.net/cilen/article/details/7744969 Collections.unmodifiableList方法的使用与场景 cilen]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>EffectiveJava第三版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>EffectiveJava第三版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第七章读书笔记]]></title>
    <url>%2F2019%2F01%2F13%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的整理知识点，方便以后回顾，这一章主要讲解了java的复用类 正文1.组合语法满足has-a关系在类中，创建一个其它类的对象，使用该对象的一些方法，对这个对象进行操作。类中域为基本类型时能自动被初始化为0，对象引用会被初始化为Null。初始化类中的引用，可以在四种情况下进行：1、在定义对象的地方（在类的构造器调用之前就初始化了）2、在类的构造器中3、在需要使用这些对象之前（惰性初始化）4、使用实例初始化 2.继承语法使用继承我们一般认为导出类是一个或者像是一个，满足is-a或者is-like-a的关系，例如圆形是一个几何形当创建一个导出类对象时，该对象包含了一个基类子对象。当初始化时，构造器的调用遵循由内到外的顺序，默认情况下调用基类的无参构造器，基类构造器都有参时，可以用super(“参数”)显式的调用基类构造器。 3.代理代理和组合就是不满足继承关系，他们是包含关系，比如飞机包含控制系统当一个类并不是另一个类的子类型，却要完全或部分用到另一个类的全部方法时，可以用代理。在类Ship中创建另一个类的对象controls，然后构造所需要的全部方法，在方法里只需要使用相应的controls.方法。即可使用对象类的所有方法。 4.结合使用组合和继承虽然编译器强制初始化基类，但是不强制初始化成员对象，所有在用组合的时候应该注意要自己初始化成员对象。可以使用try finally强制对内存进行回收清理，自己编写函数回收内存，此时回收顺序是由外向内，最后使用super.dispose()回收基类内存。Java中导出类重载某个基类方法，它并不会屏蔽其在基类中的任何版本，也就是在参数列表类型符合的情况下，基类中的该方法依旧可用。@override是覆写关键字，如果添加这个注解而错误的重载（没有覆写）该方法，那么编译器会报错。覆写（override）：函数名一样，返回值类型，参数列表类型都一样。子类函数的访问权限不能小于父类。重载（overlode）：函数名一样，参数列表不一样，返回值类型可以相同也可以不同。以上两种都是程序多态性的体现。自己编写清理方法，不要使用finalize();1.可能永远不会调用，即使被调用也是按照他想要的顺序来回收123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * Class Name: Share * Description: 清理，用来记录引用计数 * * author: CreamBing * time: 2019-01-11 14:32 * version: v1.0.0 */public class Share &#123; private int refcount = 0; private static long counter = 0; private final long id = ++counter; public Share() &#123; System.out.println("create"+this); &#125; public void addRef()&#123; refcount++; &#125; public int getRefcount() &#123; return refcount; &#125; protected void dispose()&#123; if(--refcount==0)&#123; System.out.println("dispose"+this); &#125; &#125; @Override public String toString() &#123; return "Share&#123;" + "refcount=" + refcount + ", id=" + id + '&#125;'; &#125; public static void main(String[] args) &#123; Share s1 = new Share(); Share s2 = new Share(); System.out.println("**********"); System.out.println(s1); System.out.println("************"); System.out.println(s2); &#125;&#125;/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. *//** * Class Name: Composing * Description: 共享类 * * author: CreamBing * time: 2019-01-11 14:42 * version: v1.0.0 */public class Composing &#123; private Share share; private static long count = 0; private final long id = ++count; public Composing(Share share) &#123; this.share = share; this.share.addRef(); System.out.println("create "+this); &#125; protected void dispose()&#123; System.out.println("dispose "+this); share.dispose(); &#125; @Override public String toString() &#123; return "Composing&#123;" + "share=" + share + ", id=" + id + '&#125;'; &#125;&#125;/** * Class Name: ReferenceCounting * Description: 对象引用计数 * &lt;p&gt; * author: CreamBing * time: 2019-01-11 14:48 * version: v1.0.0 */public class ReferenceCounting &#123; Share s1 = new Share(); Composing[] ca; public ReferenceCounting() &#123; this.ca = new Composing[]&#123;new Composing(s1), new Composing(s1), new Composing(s1)&#125;; &#125; @Override protected void finalize() throws Throwable &#123; if (s1.getRefcount() != 0) &#123; System.out.println("Composing没有清理干净，还有实例引用Share"); &#125; else &#123; System.out.println("Composing清理干净，开始垃圾回收"); super.finalize(); &#125; &#125; /** * createShare&#123;refcount=0, id=1&#125; * create Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=1&#125; * create Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * create Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=3&#125; * dispose Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=1&#125; * c[0] dispose * 开始强制垃圾回收 * ************************************* * dispose Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * dispose Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=3&#125; * disposeShare&#123;refcount=0, id=1&#125; * ca[1],ca[2]清理，所有Composing对象清理完毕 * 开始强制垃圾回收 * Composing清理干净，开始垃圾回收 * 注释掉********************************后面的东西 * createShare&#123;refcount=0, id=1&#125; * create Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=1&#125; * create Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * create Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=3&#125; * dispose Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=1&#125; * c[0] dispose * 开始强制垃圾回收 * ************************************* * Composing没有清理干净，还有实例引用Share * @param args */ public static void main(String[] args) &#123; ReferenceCounting r = new ReferenceCounting(); r.ca[0].dispose(); System.out.println("c[0] dispose"); System.out.println("开始强制垃圾回收"); System.runFinalizersOnExit(true); System.out.println("*************************************"); r.ca[1].dispose(); r.ca[2].dispose(); System.out.println("ca[1],ca[2]清理，所有Composing对象清理完毕"); System.out.println("开始强制垃圾回收"); System.runFinalizersOnExit(true); &#125;&#125; 5.在组合和继承之间选择is-a 继承hsa -a 组合 6.protected关键字关键字protected表明，就类用户而言，它是private的，就继承自此类的导出类或者其它位于同一个包的类来说，它是可以访问的。最好将域保持为private的，保留更改底层实现的权利。然后通过protected方法控制类的继承者的访问权限。 7.向上转型将导出类转型成基类，继承要慎用，需要向上转型时，推荐使用继承。向上转型会丢失方法和域 8.final关键字final数据：对于基本类型，final使数值恒定不变。对于对象的引用，final使引用恒定不变，但是对象自身是可以修改的。注意:数组也是一种引用。带有恒定初值（即：编译期常量）的final static 基本类型全用大写命名，并且字与字之间用下划线隔开。必须在域的定义处或者构造器中用表达式对final进行赋值，这真是final域在使用前总是初始化的原因。final参数：在函数参数列表中的final参数，在函数内无法修改它f(final int i){ i++; } //非法final方法：使用场景：1、把方法锁定，防止继承类修改，覆盖它。2、提高效率。（逐渐淘汰）类中所有的private方法都隐式地指定为final的。因为private方法无法被外界取用，所以并不算基类接口的一部分，所以尽管导出类含有相同名称的方法，但是互不干扰，也没有覆盖。 final类：使用场景：不可以作为基类被继承。 9.初始化及类的加载类的代码在初次使用时才会被加载，通常是指加载发生在创建类的第一个对象之时，在访问static域或static方法时，也会发生加载。注意，只要加载包含static方法的类，static初始化就会执行。注意子类创建对象调用构造器时基类构造器也会被调用，此时基类会被加载，基类的static将会被初始化。基类staitic–&gt;子类static–&gt;基类基本类型设为默认值0，对象引用被设为Null–&gt;基类构造器–&gt;子类基本类型设为默认值0，对象引用被设为Null–&gt;子类构造器 总结继承和组合都是从现有类型生成新类型，组合一般是将现有类型作为新类型的底层实现的一部分来加以复用，而继承复用的是接口，这对多态来说至关重要，所以分析一个系统的时候应该弄清楚那些是is-a,那些是has=a关系 参考资料https://blog.csdn.net/severusyue/article/details/49274695 Java编程思想第四版读书笔记——第七章 复用类 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第六章读书笔记]]></title>
    <url>%2F2019%2F01%2F13%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的整理知识点，方便以后回顾，这一章主要讲解了java的访问权限控制 正文1.包:库单元Java代码文件，也可以成为编译单元（有时也成为转译单元）。编译单元内有一个public类，该类名称必须与文件名称相同。每个编译单元只能有一个public类。Java包命名规则是必须全是小写字母。package和import将单一的全局名字空间分开，使得不会出现名称冲突问题。想要使用某类，需要指定全名或者使用import关键字，import可以使用该包中的public类。使用静态导入 import static可以在系统中使用包中静态的方法。 jdk5之前需要设置classpath,那是因为引入jar需要指定jar的具体目录，因为java编译需要调用javac,5之前依赖tools.jar，相当与”javac -Calsspath=%JAVA_HOME%\lib\tools.jar xx.xxx.Main XXX.java”所以需要设置，jdk5之后不建议设置classpath,设置javahome的原因也是方便命令的输入 2.Java访问权限修饰词访问权限：不加修饰词，就是包访问权限。包内所有其他类对那个成员都有访问权限。对包外类都是private。取得某成员访问权限的唯一途径是：1、该成员是public2、不加权限修饰词并将其他类放在同一个包内，包内其它成员可访问此成员。3、继承而来的类既可以访问public又可以访问protected。4、通过访问器和变异器方法（get/set方法），以读取和改变值。 public:接口访问权限：任何人都可以访问它。不同包里的都可以。 默认包：对于隶属于相同目录却没有给自己设定任何包名称的文件，Java默认其为该目录的默认包里，这样它们之间的包访问权限可以使它们互相访问。private:私有除了包含该类成员的类（这个private成员在的类）之外，任何其他类都无法访问这个成员。好处：1、可以控制如何创建该对象，别人必须使用特定构造器创建，例如单例模式，如果默认构造器是唯一并且是自己定义的private构造器，那么它可以防止被继承2、对于辅助方法，可以指定其为private，防止误用它protected:继承访问权限protected成员除了只能被派生类使用外，还提供包访问权限。 3.接口和实现访问权限的控制常被称为具体实现的隐藏，这被便是“封装”。 4.类的访问权限1、每个编译单元（文件）只能有一个public类2、public类的名称必须与文件名相匹配，包括大小写.类只能是public或者包访问权限的，除了内部类单例模式的五种实现方式1.饿汉式(线程安全，调用效率高，但是不能延时加载)1234567public class ImageLoader&#123; private static ImageLoader instance = new ImageLoader(); private ImageLoader()&#123;&#125; public static ImageLoader getInstance()&#123; return instance; &#125; &#125; 上来就把单例对象创建出来了，要用的时候直接返回即可，这种可以说是单例模式中最简单的一种实现方式。但是问题也比较明显。单例在还没有使用到的时候，初始化就已经完成了。也就是说，如果程序从头到位都没用使用这个单例的话，单例的对象还是会创建。这就造成了不必要的资源浪费。所以不推荐这种实现方式。2.懒汉式(线程安全，调用效率不高，但是能延时加载)：12345678910111213141516public class SingletonDemo2 &#123; //类初始化时，不初始化这个对象(延时加载，真正用的时候再创建) private static SingletonDemo2 instance; //构造器私有化 private SingletonDemo2()&#123;&#125; //方法同步，调用效率低 public static synchronized SingletonDemo2 getInstance()&#123; if(instance==null)&#123; instance=new SingletonDemo2(); &#125; return instance; &#125;&#125; 3.Double CheckLock实现单例：DCL也就是双重锁判断机制（由于JVM底层模型原因，偶尔会出问题，不建议使用）1234567891011121314151617public class SingletonDemo5 &#123; private volatile static SingletonDemo5 SingletonDemo5; private SingletonDemo5() &#123; &#125; public static SingletonDemo5 newInstance() &#123; if (SingletonDemo5 == null) &#123; synchronized (SingletonDemo5.class) &#123; if (SingletonDemo5 == null) &#123; SingletonDemo5 = new SingletonDemo5(); &#125; &#125; &#125; return SingletonDemo5; &#125; &#125; 4.静态内部类实现模式（线程安全，调用效率高，可以延时加载）12345678910111213public class SingletonDemo3 &#123; private static class SingletonClassInstance&#123; private static final SingletonDemo3 instance=new SingletonDemo3(); &#125; private SingletonDemo3()&#123;&#125; public static SingletonDemo3 getInstance()&#123; return SingletonClassInstance.instance; &#125; &#125; 5.枚举类（线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用）123456789public enum SingletonDemo4 &#123; //枚举元素本身就是单例 INSTANCE; //添加自己需要的操作 public void singletonOperation()&#123; &#125;&#125; 如何选用：-单例对象 占用资源少，不需要延时加载，枚举 好于 饿汉-单例对象 占用资源多，需要延时加载，静态内部类 好于 懒汉式 5.总结控制对成员的访问有两个原因：1、是用户不要去触碰不该触碰的部分2、让库类设计者可以改变类内部工作的方式，而不必担心对客户端程序员产生重大影响。 参考资料https://blog.csdn.net/severusyue/article/details/49175943?utm_source=blogxgwz1 Java编程思想第四版读书笔记——第六章 访问权限控制 severusyuehttps://www.cnblogs.com/ngy0217/p/9006716.html java单例模式几种实现方式 点点积累]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第五章读书笔记]]></title>
    <url>%2F2019%2F01%2F11%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的整理知识点，方便以后回顾，这一章主要讲解了java的初始化和清理 正文1.用构造器确保初始化使用构造器（constructor），在创建对象时初始化。分为带参数的初始化和不带参数的初始化。构造器初始化之前会先进行域的初始化，基本类型和String会被给予相应默认值 2.方法重载类型提升（向上提升）：int — long — float — double byte — short — int char — int窄化转换：和向上提升反过来，注意先考虑降到byte再考虑char返回值是无法区分重载方法的 3.默认构造器没有构造器的时候，系统会自动生成一个无参的默认构造器。如果写了构造器，就别指望系统生成了，所以如果写了带参构造器，就不能无参初始化了。另外只有私有构造器，该类无法继承 4.this关键字this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。尽管可以用this调用一个构造器，但不能调用两个。当在一个构造器中调用另一个构造器时，需要用到this关键字。并且置于最起始处将自身传递到外部方法，必须用this关键字1234567891011121314151617181920public class Peeler &#123; //需要把工具类写出来 static Apple peel(Apple apple)&#123; System.out.println("皮削了"); return apple; &#125;&#125;public class Apple &#123; Apple getPeeled()&#123; return Peeler.peel(this); &#125; public static void main(String[] args) &#123; Apple a = new Apple(); a.getPeeled(); &#125;&#125; 除构造器外，编译器禁止在其他任何方法中调用构造器。static方法是没有this的方法。所以有些人认为static方法不是“面向对象”的，这个概念还是有争议的 5.清理：终结处理和垃圾回收垃圾回收器只知道释放那些经由new分配的内存。123对象可能不被垃圾回收。垃圾回收不等于“析构”。垃圾回收只与内存有关（使用垃圾回收器的唯一原因就是回收程序不再使用的内存）。 不应该将finalize()作为统一的清理方法，因为它可能不被执行，这是一个陷阱。无论是“垃圾回收”还是“终结”，都不保证一定会发生。finalize()还有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象“终结条件”的验证。System.gc() 用于强制进行终结动作。比如强制进入finalize（随着程序的运行也许程序自己也会调用这个方法），当某个关系的标记量有异，打印出来。可供程序员找出程序代码尤其是创建对象时隐晦的缺陷。 垃圾回收器如何工作：Java虚拟机采用一种自适应的垃圾回收技术。要是没有新垃圾及产生，就会转换到 “标记——清扫”工作模式。“标记——清扫”所依据的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出存活的对象，给对象一个标记。全部标记工作完成后，清理动作才会开始。“停止——复制”的回收动作不是在后台运行的，它发生时，程序将会被暂停。它将所有活对象从旧堆复制到新堆，然后再释放旧堆中的对象所占内存。如果所有对象都很稳定，垃圾回收器的效率降低，就切换到“标记——清扫”方式，同样，Java虚拟机会追踪“标记——清扫”的效果，如果堆空间出现很多碎片，就会切换回“停止——复制”方式。Java虚拟机中有很多附加技术提升速度，比如“即时”编译器技术。这种技术将程序全部或部分翻译成本地机器码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Practice11 &#123; @Override protected void finalize() throws Throwable &#123; System.out.println("我被清理了"); super.finalize(); &#125; /** * output * Try 1: * Try 2: * Try 3: * Try 4: * 我被清理了 * @param args */ public static void main(String[] args) &#123; Practice11 p = new Practice11(); System.out.println("Try 1: "); System.runFinalization(); System.out.println("Try 2: "); Runtime.getRuntime().runFinalization(); System.out.println("Try 3: "); System.gc(); System.out.println("Try 4: "); // using deprecated since 1.1 method: System.runFinalizersOnExit(true); &#125;&#125;//用于终结条件的判断public class Practice12 &#123; //默认true,满的 private boolean flag=true; public Practice12(boolean flag) &#123; this.flag = flag; &#125; @Override protected void finalize() throws Throwable &#123; if(flag)&#123; System.out.println("我是满的,我被清理了"); super.finalize(); &#125;else &#123; System.out.println("我不是满的,我不清理"); &#125; &#125; /** * output * true * false * 我不是满的,我不清理 * 我是满的,我被清理了 * @param args */ public static void main(String[] args)throws Exception &#123; Practice12 p = new Practice12(true); Practice12 p1 = new Practice12(false); System.runFinalizersOnExit(true); Thread.sleep(10000); //貌似会保证引用调用完被清理 System.out.println(p.flag); System.out.println(p1.flag); &#125;&#125; 6.成员的初始化所有变量在使用前都能得到适当的初始化。对于函数局部变量，Java以编译错误的形式强制初始化。不初始化编译就不成功。下面是各类型基本数据的初始值123456789 boolean false char [ ] byte 0 short 0 int 0 long 0 float 0.0 double 0.0 reference null 7.构造器的初始化无法阻止自动初始化的进行，它将在构造器被调用之前发生。因此，编译器不会强制一定在构造器某个地方或者在使用它们之前对元素进行初始化——因为初始化早已得到了保证。 静态数据初始化：静态数据只占用一份存储区域。静态初始化只有在必要时候进行。只有在第一个类型对象创建（或第一次访问静态数据）的时候，他们才会被初始化。此后，静态对象不会再被初始化。初始化顺序：静态对象（只一次）——&gt; 非静态对象——&gt;构造器可以使用静态块的方式，对静态对象成员进行初始化，放在static关键字后面，如下：123456public class Spoon &#123; static int i; static &#123; i = 47; &#125; &#125; 非静态实例初始化：12345678910111213public class Mug &#123; Mug mug1; Mug mug2; &#123; mug1 = new Mug(1); mug2 = new Mug(2); System.out.println("mug1 &amp; mug2 initialized"); &#125; Mug() &#123; &#125; Mug(int i) &#123; &#125;&#125; 如上，看起来比静态块少了个static关键字，它保证了每新建一个该类的对象，不论调用何种构造器，这些操作都会发生。实例初始化子句是发生在构造器之前执行.另外这种语法对于匿名内部类的初始化是必须的 8.数组初始化注意数组的别名问题。不确定在数组里需要多少个元素时，可以直接new。在运行时再创建。这里再提一下，数组元素中基本数据类型，数字和字符会被自动初始化为0，而布尔型会自动初始化为false。Array.toString()方法属于java.util标准类库，它将产生一维数组的可打印版本。试图使用数组中的空引用（null），则会在运行时产生异常。可变参数列表(C通常称之为varags)：所谓可变参数列表，可以理解为函数的参数列表中某类型的数量是不确定的。这个特性是在JavaSE5之后添加的。12345static void printArray(Object... args) &#123; for(Object obj : args) System.out.print(obj + &quot; &quot;); System.out.println(); &#125; 有了可变参数，就不用显示的编写数组语法了，当指定参数，编译器会自动填充数组。也就是输入一个列表，编译器会自动将其转化为数组，作为可变参数列表接受。0个参数传递给可变参数列表是可行的，当局有可选的尾随参数时，这一特性就会很有用。对于如下方法：123456 static void f(int required, String... trailing) &#123; System.out.print(&quot;required: &quot; + required + &quot; &quot;); for(String s : trailing) System.out.print(s + &quot; &quot;); System.out.println(); &#125; f(0)是可以代入的，尽管并没有String类型参数。getClass()方法属于Object的一部分，它将产生对象的类，并且在打印该类时，可以看到该类型的编码字符串。前导[表示int类型。它是这样用的：1234static void g(int... args) &#123; System.out.print(args.getClass()); System.out.println(&quot; length &quot; + args.length); &#125; 输出是这样的：12345 class [Ljava.lang.Character; length 1 class [Ljava.lang.Character; length 0 class [I length 1 class [I length 0 int[]: class [I 可以在单一的参数列表中将类型混合在一起，而自动包装机制将有选择的将Int提升为Integer。可变参数列表使重载变得复杂，编译器无法知道应该调用哪种方法。因此应当总是只在重载的一个版本上使用可变参数列表，或者压根不用。数组初始化的几种方式12345678910111213141516171819202122基本数据类型 int[] a = new int[10];//创建大小为10的int数组并自动初始化为零 int[] a1 = &#123;1,2&#125;;//创建并初始化 int[] a2 = new int[]&#123;1,2,4&#125;; int[] a3 = IntStream.of(1, 2, 3, 4, 5).toArray(); Arrays.stream(a).forEach(System.out::print); System.out.println(); Arrays.stream(a1).forEach(System.out::print); System.out.println(); Arrays.stream(a2).forEach(System.out::print); System.out.println();//对于包装类型 Integer[] b1 = &#123;1,2&#125;;//创建并初始化 Integer[] b2 = new Integer[]&#123;1,2,4&#125;; Integer[] b3 = Stream.of(1, 2, 3, 4, 5).toArray(Integer[]::new); //nullnullnullnullnullnullnullnullnullnull Integer[] b4 = new Integer[10]; //试图使用数组中的空引用，空指针异常 if(b4[0]==0)&#123; System.out.println(&quot;b4[0]==0&quot;); &#125; Stream.of(b4).forEach(System.out::print); 9.枚举类型ava SE5添加了enum关键字（枚举类型的实例都是常量，因此都用大写字母表示，如果有多个单词，就用下划线隔开。）创建一个枚举类型：123public enum Spiciness &#123; NOT,MILD,MEDIUM,HOT,FLAMING &#125; 创建enum实例：Spiciness howHot = Spiciness.MEDIUM;enum的一些特性：toString() 函数可以方便的显示某个实例的名字。ordinal() 函数可以显示某个特定enum常量的申明顺序。static values() 函数可以按照enum常量的申明顺序构成相应数组。枚举类型可以配合switch case使用。 参考资料https://blog.csdn.net/severusyue/article/details/48633599 Java编程思想第四版读书笔记——第五章 初始化与清理 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第四章读书笔记]]></title>
    <url>%2F2019%2F01%2F10%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的整理知识点，方便以后回顾，这一章主要讲解了java的控制执行流程 正文1.true和falseJava不允许我们将一个数字作为布尔值使用，虽然这在C和C++里是允许的（在这些语句里，“真”是非零，“假”是零） 2.break和continuebreak用于强行退出循环，不执行循环中剩余的语句，只能跳出一层循环。而continue则停止执行当前的迭代（不执行本次循环的后续代码），然后退回循环起始处，开始下一次迭代。 3.臭名昭著的goto不提倡使用goto，会给程序带来毁灭性灾害。break和continue配合标签使用，效果更佳。12345一般continue会返回最内层循环的开头（顶部），并继续执行。带标签的continue会达到标签的位置，并重新进入紧接在那个标签后面的循环。一般break会中断并跳出当前循环。带标签的break会中断并跳出标签所指的循环。在Java里需要使用标签的唯一理由就是因为有循 在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，从而想从多层嵌套中break或continue。 4.switchswitch中的选择因子必须是int或者char那样的整数值 参考资料https://blog.csdn.net/severusyue/article/details/48632345?utm_source=blogxgwz5 Java编程思想第四版读书笔记——第四章 控制执行流程 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版前三章读书笔记]]></title>
    <url>%2F2019%2F01%2F08%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E5%89%8D%E4%B8%89%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的整理知识点，方便以后回顾 正文第一章 对象导论1.抽象过程:万物皆对象；程序是对象的集合，它们通过发送消息来告知彼此所要做的；每个对象都有自己的由其它对象构成的存储。每个对象都有其类型，每个对象都是某个类的一个实例（instance）;某一特定类型的所有对象都可以接受同样的消息。 2.每个对象都有一个接口每个对象都只能满足某些请求，这些请求是由对象的接口（interface）所定义的，决定接口的便是类型。 3.每个对象都提供服务将对象看做服务者可以提高对象的内聚性。高内聚性是软件设计的基本质量要求之一，可以将一个拥有很多功能的对象拆分成多个各司其职的对象。 4.被隐藏的具体实现为什么要进行访问控制？（1）让客户端程序员无法触及他们不该触及的部分——这些部分对于内部操作是必须的，但不是用户解决特定问题所需要的接口的一部分。减少客户端程序员需要考虑的东西，忽略不重要的东西。（2）允许库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员 5.复用具体实现复用对象：（1）直接使用该类的对象；（2）创建一个成员对象；使用现有的类合成新的类，称为“组合”，如果组合是动态发生的，则称为“聚合”。在创建新类时，优先考虑组合，再考虑继承。上面的关系可以解读如下:123456(关联)Association：A类有B类有逻辑上的连接(聚合)Aggregation : A类有一个B类(组合)Composition : A类拥有一个B类(依赖)Dependency : A类使用了B类(继承)Inheritance : B类是一个A类 (或者B类扩展A类)(实现)Realization : B类实现了接口A 6.继承导出类和基类具有相同的类型即一个圆也是一个几何形有两种方法可以使基类和导出类产生差异12直接在导出类中添加新方法，这些新方法并不是基类接口的一部分，应该考虑的是基类是否应该具备这些方法另一种更重要的使基类和导出类之间产生差异的方法是改变现有基类的方法，称为覆盖 “是一个”和“像是一个”的关系如果继承只覆盖基类的方法，意味着导出类和基类是完全相同的类型，他们具有完全相同的接口，这被称为纯粹替代。某种意义上，是继承的理想方式，为is-a关系如果继承在导出类必须添加新的接口元素，扩展了接口，这种替代并不完美，为is-like-a(像是一个)关系 7.伴随多态的可交互对象将导出类看做它的基类的过程称为向上转型。方法可以在不知道对象的实际类型时，做出正确的行为。后期绑定 8.单根继承结构除了C++以外的所有OOP语言，所有类最终都继承自单一的基类。这个终极基类即Object;单根继承使所有对象都具有统一的接口，给编程带来了更大的灵活性。垃圾回收器的实现变的容易许多。C++如果这样，优点：额外的灵活性; 缺点：需要构建自己的继承体系，不兼容 9.容器不同的容器提供了不同类型的接口和外部行;不同的容器对于某些操作具有不同的效率为了避免向下转型为错误的类型，因此有了参数化类型机制，参数化类型就是一个编译器可以自动定制用于特定类型上的类。 10.对象的创建和生命周期对象的创建C++认为效率控制是最重要的议题，在堆栈或者静态存储区域创建对象。Java在创建对象的时候可以不用知道对象的确切数量，生命周期和类型。Java完全采用了动态内存分配的方式。它认为对象变得复杂后，查找和释放存储空间的开销就不那么那么重要了。提高灵活性，牺牲了时间。对象的生命周期Java提供了“垃圾回收器”机制，可以自动发现对象何时不再被使用，继而销毁它。垃圾回收器可以避免内存溢出的问题。 11.异常处理：处理错误异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。异常不能忽略，所以它保证一定会在某处得到处理。它提供了一种从错误状况进行可靠恢复的路径。异常处理不是面向对象的特征。 12.并发编程使用线程，但是可能遇到一个隐患，就是共享资源的问题。某个任务锁定某项资源，完成其任务，然后释放资源锁，使其它任务可以使用这项资源。 13.Java与Internet客户/服务器系统的核心思想是：系统具有一个中央信息存储池，用来存储某种数据，它通常位于数据库中，你可以根据需要将它分发给某些人员或机器集群。信息存储池、用于分发信息的软件以及消息与软件所驻留的机器或机群被称为服务器; 第二章 一切都是对象1.用引用操作对象字符串可以用带引号的文本初始化 2.必须由你创建所有对象(1) 寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的 地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编 译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存 在的任何踪迹。(2) 堆栈。驻留于常规 RAM（随机访问存储器）区域，但可通过它的“堆栈 指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移， 则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。 创建程序时，Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以 及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。 这一限制无疑影响了程序的灵活性，所以尽管有些 Java 数据要保存在堆栈里— —特别是对象句柄，但 Java 对象并不放到其中。(3) 堆。一种常规用途的内存池（也在 RAM 区域），其中保存了 Java 对象。 和堆栈不同，“内存堆”或“堆”（Heap）最吸引人的地方在于编译器不必知道 要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。 因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用 new 命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当 然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉 更长的时间！(4) 静态存储。这儿的“静态”（Static）是指“位于固定位置”（尽管也在 RAM 里）。程序运行期间，静态存储的数据将随时等候调用。可用 static 关键字 指出一个对象的特定元素是静态的。但 Java 对象本身永远都不会置入静态存储 空间。(5) 常数存储。常数值通常直接置于程序代码内部。这样做是安全的，因为 它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存 储器（ROM）。(6) 非 RAM 存储。若数据完全独立于一个程序之外，则程序不运行时仍可 存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固 定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于 固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不 变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体 中。一旦需要，甚至能将它们恢复成普通的、基于 RAM 的对象。Java 1.1 提供 了对 Lightweight persistence 的支持。未来的版本甚至可能提供更完整的方案 特殊情况：主要类型 有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主” （Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由于用 new 创建对象（特别是小的、简单的变量）并不是非常有效，因为 new 将 对象置于“堆”里。所以对于这些主要类型，Java 采纳了与 C 和 C++相同的方法。也就 是说，不是用 new 创建变量，而是创建一个并非句柄的“自动”变量。这个变 量容纳了具体的值，并置于堆栈中，能够更高效地存取。 Java 决定了每种主要类型的大小。就象在大多数语言里那样，这些大小并 不随着机器结构的变化而变化。这种大小的不可更改正是 Java 程序具有很强移 植能力的原因之一。 3.特例:基本类型主类型 大小 最小值 最大值 封装器类型boolean 1 位 - - Booleanchar 16 位 Unicode 0 Unicode 2的16次方-1 Characterbyte 8 位 -128 +127 Byteshort 16 位 -2的15次方 +2的 15 次方-1 Shortint 32 位 -2的31次方 +2的 31 次方-1 Integerlong 64 位 -2的63次方 +2的 63 次方-1 Longfloat 32 位 IEEE754 IEEE754 Floatdouble 64 位 IEEE754 IEEE754 Doublefloat有一个符号位+8个指数位+23个尾数位 阶码的范围是-126～127 -126-23 即最小值为2的-149次方 最大值(2-2的-23次方)2的127次方Float.MIN_VALUE = 1.4e-45fFloat.MAX_VALUE = 3.4028235e+38fdouble一样 1+11+52 解码的范围 -1022-1023 -1022-52 即最小值为2的-1074次方 最大值(2-2的-52)2的1023次方为什么java中对于float和double定义的最小值都是正数，而不是-Float.MAX_VALUE了？因为他们不是连续的，它们有精度，无法表示整个实数，最小值也是趋近于零，float无法表示-Float.MIN_VALUE和Float.MIN_VALUE之间的值，如果最小值用-Float.MAX_VALUE是不严谨的 高精度数字Java 1.1 增加了两个类，用于进行高精度的计算：BigInteger 和 BigDecimal。 尽管它们大致可以划分为“封装器”类型，但两者都没有对应的“主类型”。 这两个类都有自己特殊的“方法”，对应于我们针对主类型执行的操作。也 就是说，能对 int 或 float 做的事情，对 BigInteger 和 BigDecimal 一样可以做。 只是必须使用方法调用，不能使用运算符。此外，由于牵涉更多，所以运算速度 会慢一些。我们牺牲了速度，但换来了精度。BigInteger 支持任意精度的整数。也就是说，我们可精确表示任意大小的整 数值，同时在运算过程中不会丢失任何信息。BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的币值计算。至于调用这两个类时可选用的构建器和方法，请自行参考联机帮助文档 4.Java 的数组在 C++里，应尽量不要使用数组，换用标准模板库（Standard TemplateLibrary）里更安全的容器。而一个 Java 可以保证被初始化，而且不可在它的范 围之外访问。由于系统自动进行范围检查，所以必然要付出一些代价：针对每个 数组，以及在运行期间对索引的校验，都会造成少量的内存开销。但由此换回的 是更高的安全性，以及更高的工作效率。为此付出少许代价是值得的。创建对象数组时，实际创建的是一个句柄数组。而且每个句柄都会自动初始 化成一个特殊值，并带有自己的关键字：null（空）。一旦 Java 看到 null，就知 道该句柄并未指向一个对象。正式使用前，必须为每个句柄都分配一个对象。若 试图使用依然为 null 的一个句柄，就会在运行期报告问题。因此，典型的数组错 误在 Java 里就得到了避免。 也可以创建主类型数组。同样地，编译器能够担保对它的初始化，因为会将 那个数组的内存划分成零。 5.作用域对于在作用域里 定义的名字，作用域同时决定了它的“可见性”以及“存在时间”。在 C，C++ 和 Java 里，作用域是由花括号的位置决定的12345678910 &#123; int x = 12; /* only x available */ &#123; int q = 96; /* both x &amp; q available */ &#125; /* only x available */ /* q “out of scope” */&#125; 注意尽管在 C 和 C++里是合法的，但在 Java 里不能象下面这样书写代码：1234567 &#123; int x = 12; &#123; int x = 96; /* illegal */ &#125;&#125; 编译器会认为变量 x 已被定义。所以 C 和 C++能将一个变量“隐藏”在一 个更大的作用域里。但这种做法在 Java 里是不允许的，因为 Java 的设计者认 为这样做使程序产生了混淆。 对象的作用域Java 对象不具备与主类型一样的存在时间。用 new 关键字创建一个 Java 对象的时候，它会超出作用域的范围之外123&#123;String s = new String(&quot;a string&quot;);&#125; /* 作用域的终点 */ 那么句柄 s 会在作用域的终点处消失。然而，s 指向的 String 对象依然占据 着内存空间。在上面这段代码里，我们没有办法访问对象，因为指向它的唯一一 个句柄已超出了作用域的边界。在后面的章节里，大家还会继续学习如何在程序 运行期间传递和复制对象句柄。 6.新建数据类型：类定义一个类时（我们在 Java 里的全部工作就是定义类、制作那些类的对象 以及将消息发给那些对象），可在自己的类里设置两种类型的元素：数据成员（有 时也叫“字段”）以及成员函数（通常叫“方法”）。其中，数据成员是一种对象 （通过它的句柄与其通信），可以为任何类型。它也可以是主类型（并不是句柄） 之一 7.主成员的默认值若某个主数据类型属于一个类成员，那么即使不明确（显式）进行初始化， 也可以保证它们获得一个默认值。主类型 默认值Boolean falseChar ‘\u0000’(null)byte (byte)0short (short)0int 0long 0Lfloat 0.0fdouble 0.0d一旦将变量作为类成员使用，就要特别注意由 Java 分配的默认值。这样做 可保证主类型的成员变量肯定得到了初始化（C++不具备这一功能），可有效遏 止多种相关的编程错误。 然而，这种保证却并不适用于“局部”变量——那些变量并非一个类的字段。所以，假若在一个函数定义中写入下述代码：int x;那么 x 会得到一些随机值（这与 C 和 C++是一样的），不会自动初始化成零。 我们责任是在正式使用 x 前分配一个适当的值。如果忘记，就会得到一条编译期 错误，告诉我们变量可能尚未初始化。这种处理正是 Java 优于 C++的表现之一。 许多 C++编译器会对变量未初始化发出警告，但在 Java 里却是错误。 8: 方法、自变量和返回值迄今为止，我们一直用“函数”（Function）这个词指代一个已命名的子例程。 但在 Java 里，更常用的一个词却是“方法”（Method），代表“完成某事的途径”。 尽管它们表达的实际是同一个意思，但从现在开始，本书将一直使用“方法”， 而不是“函数”。Java 的“方法”决定了一个对象能够接收的消息。Java 的方法只能作为类的一部分创建。只能针对某个对象调用一个方法(正如马上就要学到的那样，“静态”方法可针对类调用，毋需一个对象)int x = a.f();象这样调用一个方法的行动通常叫作“向对象发送一条消息”。在上面的例 子中，消息是 f()，而对象是 a。面向对象的程序设计通常简单地归纳为“向对象 发送消息”。正如在 Java 其他地方处理对象时一样，我们实际传递的是“句柄”（注释④）。④：对于前面提及的“特殊”数据类型 boolean，char，byte，short，int， long，，float 以及 double 来说是一个例外。但在传递对象时，通常都是指传递指 向对象的句柄。 9：使用其他组件用 import 关键字准确告诉 Java 编译器我们希望的类是什么。import 的作用是 指示编译器导入一个“包”——或者说一个“类库”（在其他语言里，可将“库” 想象成一系列函数、数据以及类的集合。但请记住，Java 的所有代码都必须写 入一个类中）。1import java.util.Vector; 它的作用是告诉编译器我们想使用 Java 的 Vector 类。然而，util 包含了数 量众多的类，我们有时希望使用其中的几个，同时不想全部明确地声明它们。为 达到这个目的，可使用“*”通配符。如下所示：123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;``` 需导入一系列类时，采用的通常是这个办法。应尽量避免一个一个地导入类#### 10:static 关键字通常，我们创建类时会指出那个类的对象的外观与行为。除非用 new 创建那 个类的一个对象，否则实际上并未得到任何东西。只有执行了 new 后，才会正 式生成数据存储空间，并可使用相应的方法。但在两种特殊的情形下，上述方法并不堪用。一种情形是只想用一个存储区 域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。另 一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是 说，即使没有创建对象，也需要一个能调用的方法。为满足这两方面的要求，可 使用 static（静态）关键字。一旦将什么东西设为 static，数据或方法就不会同 那个类的任何对象实例联系到一起当然，在正式使用前，由于static 方法不需要创建任何对象，所以它们不可简单地调用其他那些成员，同时不引用 一个已命名的对象，从而直接访问非 static 成员或方法（因为非 static 成员和方 法必须同一个特定的对象关联到一起）。&lt;font color=&quot;#eb4d4b&quot;&gt;尽管是“静态”的，但只要应用于一个数据成员，就会明确改变数据的创建 方式（一个类一个成员，以及每个对象一个非静态成员）。若应用于一个方法， 就没有那么戏剧化了。对方法来说，static 一项重要的用途就是帮助我们在不必 创建对象的前提下调用那个方法。正如以后会看到的那样，这一点是至关重要的 ——特别是在定义程序运行入口方法 main()的时候。 和其他任何方法一样，static 方法也能创建自己类型的命名对象。所以经常 把 static 方法作为一个“领头羊”使用，用它生成一系列自己类型的“实例”。&lt;/font&gt;## 第三章 操作符#### 1.使用Java操作符几乎所有Java操作符都只能操作“基本类型”，例外的是“=”，“==”和“!=”String类型支持“+”和“+=”#### 2.赋值对象的赋值其实是将“引用”赋值到另一个地方。如 c = d;那么c和d都指向原本只有d指向的对象。下面这个小例子挺好的t2赋给t1后，并非是互相独立桥归桥路归路。而是绑定在一起共同操作同一个对象。这种特殊的现象称为“别名现象”。#### 3.算术操作符整数除法后直接去掉小数位，而非四舍五入的结果。Random类对象#### 4.关系操作符==和!= 比较的是对象的引用。```javapublic class Equivalence &#123;public static void main(String[] args) &#123;Integer n1 = new Integer(47);Integer n2 = new Integer(47);System.out.println(n1 == n2);System.out.println(n1 != n2);&#125;&#125; /* Output:falsetrue 需要比较对象的实际内容使用equals()，此方法不适合基本类型。然而，对于自定义类，需要比较对象的内容时，还需要覆盖equals()方法 5.逻辑操作符与&amp;&amp;，或||，非！在使用逻辑操作符时，会遇到短路现象，即boolean a =（2&gt;1）&amp;&amp; (3&lt;1) &amp;&amp; (5&gt;2) &amp;&amp; (9&gt;3);在计算到(3&gt;1)为false时，后续两个式子就不再计算，结果a = false不会再改变 5.直接常量直接常量后缀表明了它的类型，大写（或小写）L，表示long，大写（或小写）F，表示float，大写D，表示double如：long n3 = 200;float f4 = 1r-43f;十六进制 0x(0X) + 0~f八进制 0+0~7将变量初始化的超出表示范围，编译器会报错。通过使用Integer和Long的toBinaryString()方法，可以轻松又随意的以二进制形式表示。Java的指数计数法中，e表示10的幂次而非自然数2,.71那个e：float = 1.39e-43f;表示1.39*10^(-43) 6.直接常量与&amp;，或|，非~，异或^&amp;=，!=，^=。然而并没有~=，因为~是一元操作符。对于布尔值，按位操作符具有与逻辑操作符相同效果，但是它们不会中途短路。 7.移位操作符左移位操作符（&lt;&lt;），低位补0。“有符号”右移位操作符（&gt;&gt;），高位补0，符号保留。“无符号”右移位操作符（&gt;&gt;&gt;），无论正负，高位补0。char，byte，short移位前会被转换为int类型，得到结果也是int类型，只有右端低5位有效。（int类型只有32位）。因此无符号右移时，它们会被先转成Int型，然后右移操作，然后截断，赋值给原来的类型，在这种情况下可能导致-1的结果。 8.类型转换操作符可以对变量或者数值进行类型转换（cast）。如果执行窄化转换，数据可能会丢失，编译器会觉得是不是我们搞错了没注意到，此时需要显式的进行类型转换，强调一下。执行扩展转换，则不必显式的进行类型转换。float和double转化为整型值时，总会对该数字执行截尾。对于基本数据类型进行算术运算或按位运算，只要类型比int小，在运算前这些书会自动转换成int，即会自动执行数据类型提升。表达式中出现最大的数据类型决定了表达式最终的数据类型。 参考资料https://my.oschina.net/jackieyeah/blog/224265 UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现 JackieYeahhttps://www.cnblogs.com/yanquan/p/7248933.html 《THINKING IN JAVA》–第二章一切都是对象 延泉https://blog.csdn.net/severusyue/article/details/48576589 Java编程思想第四版读书笔记——第三章 操作符 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯与递归]]></title>
    <url>%2F2019%2F01%2F07%2F%E5%9B%9E%E6%BA%AF%E4%B8%8E%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[前言最近在leetcode刷题，对于平常不是很清楚的一些数据结构和算法重新回顾和巩固一遍 目的了解回溯和递归的区别，另外弄清楚回溯的特点和应用场景 正文回溯和递归的区别和联系12递归:递归是一种算法结构,函数调用本身,最直接的递归应用就是计算连续数的阶乘，计算规律：n!=(n-1)!*n，还有汉诺塔的实现回溯:在按某种搜索策略搜索的过程中，当到达某一状态时，继续向前搜索已经确定不会得到正确答案的情况下，可以返回上一搜索状态，沿着新的可能性继续搜索。其求解过程的实质是一个先序遍历一棵“状态树”的过程 两者之间的联系:回溯多用递归实现 回溯的特点123搜索策略:符合递归算法，问题解决可以化为子问题，算法类似，规模减小;控制策略:当遇到失败的搜索状态，需要返回上一状态，沿另外的路径搜索;数据结构:一般用数组保存搜索过程中的状态、路径。 选择回溯的前提123选择：对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列条件：对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回结束：当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数 回溯参数的设计1234必须要有一个临时变量(可以就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是，把每次递归的不同情况传递给递归调用的函数。可以有一个全局变量，用来存储完整的每个解，一般是个集合容器（也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可）。最重要的一点，一定要在参数设计中，可以得到结束条件。一个选择是可以传递一个量n，也许是数组的长度，也许是数量，等等。要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯。 扩展#784 LetterCasePermutation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.creambing.leetcode.backtracking;import java.util.LinkedList;import java.util.List;/** * Class Name:LetterCasePermutation784 * Description:字母大小写全排列 * * @author Bing * @create 2019-01-07 20:52 * @version v1.0 */public class LetterCasePermutation784 &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; //全局的结果集合，作为回溯入参，保存完整结果 List&lt;String&gt; result = new LinkedList&lt;&gt;(); //开始回溯，这里选用字符数组，方便遍历以及替换字符，同时还可以连接成完整结果 backtracking(S.toCharArray(), 0, result); return result; &#125; private void backtracking(char[] s, int pos, List&lt;String&gt; result) &#123; result.add(new String(s)); for (int j = pos; j &lt; s.length; j++) &#123; char ch = s[j]; if (Character.isAlphabetic(ch)) &#123; s[j] = flip(ch); backtracking(s, j+1, result); s[j]= ch; &#125; &#125; &#125; private char flip(char ch)&#123; return Character.isUpperCase(ch)? Character.toLowerCase(ch):Character.toUpperCase(ch); &#125; public static void main(String[] args) &#123; String s ="ab14c"; new LetterCasePermutation784().letterCasePermutation(s).forEach(System.out::println); &#125;&#125; 思路根据上面的对于回溯的理解设计参数，我们从最简单的情景来设计程序，假设串是a,那么结果就是a,A,那么这个最简单的逻辑是什么了？先把当前串写入集合中，把第i个字母大小转换(数字不管)就是下面这段,要注意的是:要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯,因此注释的那段很重要，要加上，否则回溯会有问题1234567891011121314public class LetterCasePermutation784 &#123; private void backtracking(char[] s, int pos, List&lt;String&gt; result) &#123; result.add(new String(s)); for (int j = pos; j &lt; s.length; j++) &#123; char ch = s[j]; if (Character.isAlphabetic(ch)) &#123; s[j] = flip(ch); backtracking(s, j+1, result); //s[j]= ch; &#125; &#125; &#125;&#125; 运行结果截图运行流程分析Runtime: 10 ms, faster than 45.47% of Java online submissions for Letter Case Permutation. #401 BinaryWatch(二进制手表) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.creambing.leetcode.backtracking;import java.util.ArrayList;import java.util.List;/** * Class Name:BinaryWatch401 * Description:二进制手表 * * @author Bing * @version v1.0 * @create 2019-01-08 19:00 */public class BinaryWatch401 &#123; public List&lt;String&gt; readBinaryWatch(int num) &#123; int[] hoursc = &#123;1, 2, 4, 8&#125;; int[] minutec = &#123;1, 2, 4, 8, 16, 32&#125;; List&lt;String&gt; result = new ArrayList&lt;&gt;(); //我们想给了n个灯亮，那么我们正常就是先在hour中选，然后在minute中选，差不多想到下面这种逻辑 List&lt;Integer&gt; hourList = new ArrayList&lt;&gt;(); List&lt;Integer&gt; minuteList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; //这里面关于最后一个回溯参数先前没有考虑，getHour中i=0开始遍历的，这里设置参数的原因是选过了就不能再选了 getHour(i, hourList, 0, hoursc, 0); getMinu(num - i, minuteList, 0, minutec, 0); for (int hour : hourList) &#123; for (int minu : minuteList) &#123; result.add(hour+":"+(minu&lt;10?"0"+minu:minu)); &#125; &#125; //这里一定要清空 hourList.clear(); minuteList.clear(); &#125; return result; &#125; private void getHour(int n, List&lt;Integer&gt; hourList, int hour, int[] hoursc, int index) &#123; //这段可以不加，但是为了效率，加上 if (n &lt; 0) &#123; return; &#125; if (n == 0 &amp;&amp; hour &lt; 12) &#123; hourList.add(hour); &#125; for (int i = index; i &lt; hoursc.length; i++) &#123; getHour(n - 1, hourList, hour + hoursc[i], hoursc, i + 1); &#125; &#125; private void getMinu(int n, List&lt;Integer&gt; minuList, int minu, int[] minuc, int index) &#123; if (n &lt; 0) &#123; return; &#125; if (n == 0 &amp;&amp; minu &lt; 60) &#123; minuList.add(minu); &#125; for (int i = index; i &lt; minuc.length; i++) &#123; getMinu(n - 1, minuList, minu + minuc[i], minuc, i + 1); &#125; &#125;&#125; 这里拿到题目之后，感觉可以用回溯发，开始设计回溯参数 1.最开始的时候没有设计最后一个参数，for循环中i=0而不是index,这样导致选了之后在选，重复了，这里我们没有恢复状态，因为我们也没有改变状态，我们只是遍历取合适的值 2.另外一个小问题是组合的时候需要清空列表Runtime: 3 ms, faster than 56.44% of Java online submissions for Binary Watch. 其他需要回溯方法解决的leetcode题目:https://leetcode.com/tag/backtracking/ 参考资料1.https://www.jianshu.com/p/4c5ccac18fac 递归2-回溯与递归 偏偏注定要落脚丶2.https://blog.csdn.net/u014772862/article/details/51789015 回溯和递归区别 繁拾简忆3.https://blog.csdn.net/sinat_27908213/article/details/80599460 回溯算法超通俗易懂详尽分析和例题 littlelufisher]]></content>
      <categories>
        <category>算法</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7在线安装docker]]></title>
    <url>%2F2018%2F11%2F30%2Fcentos7%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[前言在线在centos7安装docker 目的CentOS Linux release 7.5.1804 (Core)docker-ce.x86_64 3:18.09.0-3.el7 正文1.确认系统是否是centos7，内核在3.10以上123uname -r或者cat /etc/redhat-release 2.执行如下命令安装在root用户下，或者在sudo执行123456789yum install -y yum-utils \ device-mapper-persistent-data \ lvm2yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo yum install docker-ce 在第一次执行安装命令时，无法解析远程仓库，此时用浏览器访问了一下,确认可以访问，于是再次执行，安装成功，这说明这个网站针对国内不够稳定，最后下载的时候确实显示速度也比较慢所以这里可以切换成阿里的源 http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo3.启动并验证12systemctl start docker.servicedocker run hello-world 参考资料1.docker官方网站[https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-repository]]]></content>
      <categories>
        <category>centos7</category>
        <category>docker</category>
        <category>在线</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>docker</tag>
        <tag>在线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装mangodb和redis]]></title>
    <url>%2F2018%2F11%2F29%2Fdocker%E5%AE%89%E8%A3%85mangodb%E5%92%8Credis%2F</url>
    <content type="text"><![CDATA[前言在有docker环境和docker-compose的工具的机器上，快速搭建redis和mangodb的单机服务 目的由于我在window上安装了docker,具体教程可看windows上安装docker-ce，以下命令都是在windows上操作 正文安装redis在cmd中执行以下命令下载redis镜像1docker pull redis 在redis服务需要启动的目录中新建redis.yml文件，里面写入如下内容1234567891011121314151617181920version: '3.1'services: redis: image: redis:latest container_name: redis hostname: redis restart: always networks: static-network: ipv4_address: 172.21.0.2 ports: - "16379:6379"networks: static-network: ipam: config: - subnet: 172.21.0.0/16 注意我们这里对于redis所在容器的ip进行了指定，当然也可以不用指定，可以服务开启后自己查看ip地址，另外容器ip不用172.21.0.1,不然会报错地址已被使用进入redis.yml文件所在目录执行1docker-compose -f redis.yml up -d 截图如下利用redis-client客户端连接(客户端下载地址 https://redisdesktop.com/download)这里在window下有个问题，就是我这里重新又定义了一个网络，我发现我不能ping通172.21.0.2这个容器ip，所以只能通过127.0.0.1:16379连接不过之前定义的consuls的网络是可以ping通的,后来发现ping通的不是docker中的，而是电信网关连接的其他网络，我们现在将网络改为consuls桥接的网络看看123456789101112131415161718version: '3.1'services: redis: image: redis:latest container_name: redis hostname: redis restart: always networks: consuls_static-network: ipv4_address: 172.20.0.5 ports: - "16379:6379"networks: consuls_static-network: external: true 这里只是展示一下docker-compose使用已有网络的写法，虽然改了能够ping通，但不是这个网络，这个和linux上有差别 linux上docker新建桥接网络，是可以互通的，但是windows上不行我注意到docker 的setting中有network这个选项然后我们查看一下window的路由链路1route print 这里我们发现10.0.75.0/24的子网的网关为10.0.75.1和docker setting配置一样，正好对上了，但是并没有172.20.0.5的子网，虽然docker中已经有了，这也正说明windows上的docker和linux上的docker不一样，因为linux上只要新建了网络，就有链路了所以我们这里新建一个匹配的桥接网络1docker network create -d bridge --subnet=10.0.75.0/24 --gateway=10.0.75.1 usable_net 123456789101112131415161718192021222324version: '3.1'services: redis: image: redis:latest container_name: redis hostname: redis restart: always networks: usable_net: ipv4_address: 10.0.75.5 ports: - "16379:6379"networks: usable_net: external: true#或者如下networks: usable_net: ipam: config: - subnet: 10.0.75.0/24 结果我发现这样做之后redis都连接不上了，于是还原回去利用最开始的方法，自己自定义网络，但是我们发现我们自定义的网络中连网关都没有 扩展这部分是在Linux作为宿主机的测试，centos7在线安装docker + linux上安装docker-compose(centos7.5+docker18.09+docker-composev1.22.0)因为可以ping通，所以我在linux宿主机上既可以通过本地的16379也可以用docker的ip(172.21.0.2)+6379访问，但是在windows上我只能用16379,因为docker机器我无法ping通 这里遗留了两个问题:12windows上network配置有什么用？为什么windows作为宿主机无法ping通自定义桥接网络的容器ip? 但是我们还是无法ping通，我们手动添加路由试试1route add 192.172.0.0 mask 255.255.0.0 192.168.5.105 https://download.studio3t.com/studio-3t/windows/2018.5.1/studio-3t-x64.zip 参考资料1.docker-compose v3 [https://docs.docker.com/compose/compose-file/#ipv4_address-ipv6_address]2.docker-compose networks [https://docs.docker.com/compose/networking/#configure-the-default-network]]]></content>
      <categories>
        <category>docker-compose</category>
        <category>mangodb</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>mangodb</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs微服务集成consul]]></title>
    <url>%2F2018%2F11%2F23%2Fnodejs%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90consul%2F</url>
    <content type="text"><![CDATA[前言使用Sidecar来整合非jvm微服务这篇文章讲解了非jvm集成到springcloud体系中的方法 需要说明的是上述方法是用Netflix的sidecar,然而它依赖Eureka作为服务发现组件，consul有自己的注册接口 目的利用consul的http api将nodejs微服务注册到consul中 正文js中有目前实现最为完备的Consul 客户端是node-consul它支持的功能有123456789ACL: 访问控制Agent: 检查/服务注册Health: 健康信息获取Catalog: 目录列表KV: 键值对存取Event: 发送事件与列表Query: 查询服务信息Status: Raft一致性的状态信息... 不过我目前就只需要当node程序启动时能将服务注册到consul中，关闭程序时能注销我发现Consul-SDK实现了这一点使用方法在nodejs工程目录下运行命令安装,当时安装的版本为1.1.9，其中依赖的consul(即node-consul)版本为0.27.0，当前最新为0.34.11npm i consul-sdk --save 在根目录下添加consul.json，check是我后面添加健康检查自己修改源码所加的配置123456789101112&#123; "serverHost": "localhost", "serverPort": 18500, "secure": false, "name": "node-service", "host": "192.168.5.105", "port": 3000, "check":&#123; "http":"http://192.168.5.105:3000/health", "interval":"10s" &#125;&#125; 在app.js中引入consul-sdk1require('consul-sdk'); 这样在项目启动和结束就会触发相应的注册和注销操作由于我现在的consul服务器端版本是1.3.0，这个js版本的consul客户端版本是0.27.0，其中注销时报错405，get方法不被允许需要修改consul源码包中service.js中注销逻辑中get方法为put方法，和注册一样我们对比一下js版本的consul客户端和java版本的客户端(spring-cloud-starter-consul-discovery),在服务发现的功能上12js实现了服务注册和注销，但是还没有健康检查，如果注销失败会出现下面截图中出现的事情，服务在consul上依然存在并且正常java实现了服务注册和健康检查，并没有服务注销(不知道是不是我没有配置) 其实node-consul是支持健康检查的，只不过consul-sdk不支持，但它是依赖node-consul来做的，我们把consul-sdk源码修改一下其实consul-sdk是对consul的一层封装，作者用es5写的，可以借鉴思路自己改写同时配置文件添加上面那一段check.下面我们在我们之前实现的网关服务中springcloud使用zuul聚合微服务添加代码来调用一下node中的相关服务添加服务类和控制类1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class NodeRibbonService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "fallback") public String getHealthInfo() &#123; return restTemplate.getForObject("http://node-service/health", String.class); &#125; public String fallback(Throwable throwable) &#123; System.out.println("node-service /health 报错:"+throwable); Map&lt;String, Object&gt; map = Maps.newHashMap(); map.put("status", "unkown"); return new Gson().toJson(map); &#125;&#125;@RestController@RequestMapping("/un")public class UserAndNodeController &#123; @Autowired UserRibbonService userRibbonService; @Autowired NodeRibbonService nodeRibbonService; @RequestMapping(value = "/getUserAndNodeHealth",method = RequestMethod.GET) public Map&lt;String, Object&gt; getUserAndNodeHealth()&#123; List&lt;User&gt; users = userRibbonService.getAllUsers1(); String s = nodeRibbonService.getHealthInfo(); Map&lt;String, Object&gt; map = Maps.newHashMap(); map.put("users",users); map.put("node",s); return map; &#125;&#125; 调用接口http://localhost:1051/un/getUserAndNodeHealth关掉node服务，但是没有在consul上注销并且consul上显示node服务正常利用上面修改源码程序退出成功在consul上注销后再调用关掉node程序，增加健康检查后，但是在consul上不注销，此时consul上显示node服务不健康，调用该接口直接走hytrix,和java类似 参考资料1.js版本的consul客户端 [https://github.com/silas/node-consul#agent-service-register]2.Consul-SDK博客地址 [http://www.moye.me/2016/10/26/node-consul-sdk/]3.consul-sdkgithub地址 [https://github.com/rockdragon/node-consul-sdk]4.consul官网service的http api [https://www.consul.io/api/agent/service.html]]]></content>
      <categories>
        <category>nodejs</category>
        <category>consul</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Sidecar来整合非jvm微服务]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%BD%BF%E7%94%A8Sidecar%E6%9D%A5%E6%95%B4%E5%90%88%E9%9D%9Ejvm%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[前言由于语言多样，系统复杂，有时候一个健壮的系统可能是由多种语言组成的，针对一个非jvm的接口平台，我们可以利用sidecar整合进来 目的利用zuul可以调用已经注册到注册中心的服务，利用sidecar调用非jvm的服务，这样就可以对外提供一个整合了jvm和非jvm的网关服务 正文利用idea新建一个node项目在idea中新建一个node工程，没有的话，先添加nodejs插件 编写node项目，添加health端点在app.js中添加123var healthRouter = require('./routes/health');app.use('/health', healthRouter); 在routes中添加health.js中添加如下123456789var express = require('express');var router = express.Router();/* GET users listing. */router.get('/', function(req, res, next) &#123; res.send(JSON.stringify(&#123;"status":"UP"&#125;));&#125;);module.exports = router; 访问http://localhost:3000/health显示 编写java sidecar整合这个node服务参考资料]]></content>
      <categories>
        <category>java</category>
        <category>springcloud</category>
        <category>sidecar</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>sidecar</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud使用zuul聚合微服务]]></title>
    <url>%2F2018%2F10%2F30%2Fspringcloud%E4%BD%BF%E7%94%A8zuul%E8%81%9A%E5%90%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[前言1.springcloud编写用户微服务2.springcloud编写电影微服务3.springcloud集成网关ZUUL依上面教程，我已经实现了用户，电影微服务以及zuul网关，微服务的设计难点之一在于对原有业务的拆分，在我看来每个微服务职责要尽可能单一，但是这样同样也带来了一个问题，那就是微服务之间不可避免的一些交集.例如终端需要查询用户信息和电影信息，这里有两种做法1.让终端查询用户信息后在查询电影信息2.网关层查询用户信息和电影信息，聚合后返回给终端后一种方式显然更好一些，因为他节省了带宽，相较于终端两次请求网关，显然网关两次请求微服务的网络情况更好 目的利用RXJAVA聚合微服务，这里面其实很多东西可以讨论，关于分布式协议和分布式事务,这次先简单的说明一下查询聚合，因为查询是幂等操作，不需要事务 正文工程初始化可以参见这篇博客springcloud集成网关ZUUL验证:http://localhost:1051/api/user/user/getAllhttp://localhost:1051/api/movie/movie/findOneById?id=2 集成feign,添加用户和电影的消费端可以参见这篇博客springcloud集成feign仿照user创建movie的feign客户端1234567891011121314@FeignClient(name = &quot;consul-movie&quot;)public interface MovieFeignClient &#123; @RequestMapping(value = &quot;/movie/findOneById&quot;,method = RequestMethod.GET) Movie findOneById(@RequestParam(&quot;id&quot;) Long id);&#125;错误的写法@FeignClient(name = &quot;consul-movie&quot;)public interface MovieFeignClient &#123; @RequestMapping(value = &quot;/movie/findOneById&quot;,method = RequestMethod.GET) Movie findOneById(Long id);&#125; get多参数写法12直接写Long id或者直接是User user这种对象，feign依然会用post方式调用，所以会报错接口不支持需要用@RequestParam(&quot;id&quot;)注解，或者@RequestParam Map&lt;String,Object&gt; map 扩展 20181031更新:zuul上的service中添加hystrix回退并没有执行，如下图，想着service中利用的是feign实现的，所以给feign加上回退，需要在配置上加上feign.hystrix.enabled=true123456789101112131415161718192021222324252627282930313233343536373839404142@FeignClient(name = "consul-movie",fallback = MovieFeignClient.MovieFeignClientFallBack.class)public interface MovieFeignClient &#123; @RequestMapping(value = "/movie/findOneById",method = RequestMethod.GET) Movie findOneById(@RequestParam("id") Long id); @Component class MovieFeignClientFallBack implements MovieFeignClient&#123; @Override public Movie findOneById(Long id) &#123; Movie movie = new Movie(); movie.setId(-1L); return movie; &#125; &#125;&#125;//加上日志的版本@FeignClient(name = "consul-movie",fallbackFactory = MovieFeignClient.MovieFeignClientFallBackFactory.class)public interface MovieFeignClient &#123; @RequestMapping(value = "/movie/findOneById",method = RequestMethod.GET) Movie findOneById(@RequestParam("id") Long id); @Component class MovieFeignClientFallBackFactory implements FallbackFactory&lt;MovieFeignClient&gt;&#123; private static final Logger LOGGER = LoggerFactory.getLogger(MovieFeignClientFallBackFactory.class); @Override public MovieFeignClient create(Throwable throwable) &#123; return new MovieFeignClient() &#123; @Override public Movie findOneById(Long id) &#123; LOGGER.error("MovieFeignClient findOneById fallback;reason was:[&#123;&#125;]",throwable); Movie movie = new Movie(); movie.setId(-1L); return movie; &#125; &#125;; &#125; &#125;&#125; 集成ribbon添加一个配置类java123456789@Componentpublic class RibbonConf &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 添加ribbon调用服务类123456789101112131415161718192021222324252627282930313233343536@Servicepublic class MovieRibbonService &#123; @Autowired private RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "fallback") public Observable&lt;Movie&gt; findOneById(Long id) &#123; return Observable.create(observer -&gt; &#123; Movie movie = restTemplate.getForObject("http://consul-movie/movie/findOneById", Movie.class, id); observer.onNext(movie); observer.onComplete(); &#125;); &#125; public Observable&lt;Movie&gt; fallback(Long id) &#123; return Observable.create(observer -&gt; &#123; Movie movie = new Movie(); movie.setId(-1L); observer.onNext(movie); observer.onComplete(); &#125;); &#125; @HystrixCommand(fallbackMethod = "fallback1") public Movie findOneById1(Long id) &#123; return restTemplate.getForObject("http://consul-movie/movie/findOneById", Movie.class, id); &#125; public Movie fallback1(Long id,Throwable throwable) &#123; System.out.println("consul-movie /movie/findOneById 报错:"+throwable); Movie movie = new Movie(); movie.setId(-1L); return movie; &#125;&#125; 新建聚合controller和服务(RXjava)针对feign实现的service,之前在上面截图中可以发现我在上面加了HystrixCommand没有用，所以去掉了，不知道是不是因为里面是feign实现的，所以下面会有ribbon实现123456789101112131415161718192021222324252627282930313233343536/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.springcloud.consulzuulum.service.rxjava;import com.springcloud.consulzuulum.feign.movie.Movie;import com.springcloud.consulzuulum.feign.movie.MovieFeignClient;import io.reactivex.Observable;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * Class Name:MovieService * Description:movie rxjava 服务类 * * @author Bing * @version v1.0 * @create 2018-10-30 22:01 */@Servicepublic class MovieService &#123; @Autowired MovieFeignClient movieFeignClient; public Observable&lt;Movie&gt; findOneById(Long id) &#123; return Observable.create(observer -&gt; &#123; Movie movie = movieFeignClient.findOneById(id); observer.onNext(movie); observer.onComplete(); &#125;); &#125;&#125; 控制类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.springcloud.consulzuulum.controller;import com.google.common.collect.Maps;import com.springcloud.consulzuulum.feign.movie.Movie;import com.springcloud.consulzuulum.feign.movie.MovieFeignClient;import com.springcloud.consulzuulum.feign.user.User;import com.springcloud.consulzuulum.feign.user.UserFeignClient;import com.springcloud.consulzuulum.service.rxjava.MovieService;import com.springcloud.consulzuulum.service.rxjava.UserService;import io.reactivex.Observable;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.context.request.async.DeferredResult;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Class Name:UserAndMovieController * Description:用户和电影聚合控制类 * * @author Bing * @version v1.0 * @create 2018-10-30 17:11 */@RestController@RequestMapping("/um")public class UserAndMovieController &#123; @Autowired UserFeignClient userFeignClient; @Autowired MovieFeignClient movieFeignClient; @Autowired UserService userService; @Autowired MovieService movieService; @RequestMapping(value = "/getUserAndMovie", method = RequestMethod.GET) Map&lt;String, Object&gt; getUserAndMovie(Long id) &#123; Long startTime = System.currentTimeMillis(); Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); //同步调用 List&lt;User&gt; users = userFeignClient.getAllUser(); Movie movie = movieFeignClient.findOneById(id); result.put("users", users); result.put("movie", movie); Long endTime = System.currentTimeMillis(); System.out.println("getUserAndMovie同步调用花费时间:"+(endTime-startTime)); return result; &#125; @RequestMapping(value = "/getUserAndMovieUseRx", method = RequestMethod.GET) DeferredResult&lt;HashMap&lt;String,Object&gt;&gt; getUserAndMovieUseRx(Long id) &#123; Long startTime = System.currentTimeMillis(); //rx异步调用 Observable&lt;HashMap&lt;String,Object&gt;&gt; observable = aggregateObservable(id); DeferredResult&lt;HashMap&lt;String,Object&gt;&gt; result = toDefer(observable); Long endTime = System.currentTimeMillis(); System.out.println("getUserAndMovieUseRx异步调用花费时间:"+(endTime-startTime)); return result; &#125; public Observable&lt;HashMap&lt;String,Object&gt;&gt; aggregateObservable(Long id)&#123; return Observable.zip( userService.getAllUsers(), movieService.findOneById(id), (users,movie) -&gt; &#123; HashMap&lt;String,Object&gt; map = Maps.newHashMap(); map.put("users",users); map.put("movie",movie); return map; &#125; ); &#125; public DeferredResult&lt;HashMap&lt;String,Object&gt;&gt; toDefer(Observable&lt;HashMap&lt;String,Object&gt;&gt; details)&#123; DeferredResult&lt;HashMap&lt;String, Object&gt;&gt; result = new DeferredResult&lt;&gt;(); details.subscribe(new Observer&lt;HashMap&lt;String, Object&gt;&gt;() &#123; @Override public void onSubscribe(Disposable disposable) &#123; System.out.println(""); &#125; @Override public void onNext(HashMap&lt;String, Object&gt; stringObjectHashMap) &#123; result.setResult(stringObjectHashMap); &#125; @Override public void onError(Throwable throwable) &#123; System.out.println("发生错误:"+throwable); &#125; @Override public void onComplete() &#123; System.out.println("完成"); &#125; &#125;); return result; &#125;&#125; 访问feign http://localhost:1051/um/getUserAndMovieUseRx?id=1 hystrix有效rxjava+ribbon http://localhost:1051/um/getUserAndMovieUseRibbon?id=1 hystrix无效ribbon http://localhost:1051/um/getAllUserRibbon hystrix有效ribbon http://localhost:1051/um/getUserAndMovieUseRibbon1?id=1 hystrix有效]]></content>
      <categories>
        <category>java</category>
        <category>springcloud</category>
        <category>zuul</category>
        <category>rxjava</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>zuul</tag>
        <tag>rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud编写电影微服务]]></title>
    <url>%2F2018%2F10%2F30%2Fspringcloud%E7%BC%96%E5%86%99%E7%94%B5%E5%BD%B1%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[前言1.springcloud Finchley.SR2版本2.springboot 版本2.0.6.RELEASE3.h24.jooq5.consul搭建一个电影微服务 目的利用idea快速搭建一个springcloud集成上述功能的微服务，可以查询电影 正文初始化工程方法跟springcloud编写用户微服务中前期准备工程一般，勾选下列依赖在resources文件夹下新增bootstrap.yml文件，写入以下内容123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1018spring: application: #项目名称 name: consul-movie cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: consul-movie #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.150:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 初始化H2数据库这时候决定手动初始化datasource,同时集成第三方数据库连接池进来，详情springboot集成druid此时consul上的配置如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758spring: datasource: url: jdbc:h2:mem:test #url: jdbc:h2:file:~/.h2/testdb #url: jdbc:h2:~/testuser driverClassName: org.h2.Driver username: sa password: 123456 platform: h2 schema: classpath:db/schema.sql data: classpath:db/data.sql initialization-mode: always #springboot2.0加上上述sql才会执行 # 下面为druid连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 minIdle: 3 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select &apos;x&apos; testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计 filters: stat # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true h2: console: settings: web-allow-others: true #进行该配置后，h2 web consloe就可以在远程访问了。否则只能在本机访问。 path: /h2-console #进行该配置，你就可以通过YOUR_URL/h2-console访问h2 web consloe。YOUR_URL是你程序的访问URl。 enabled: true #进行该配置，程序开启时就会启动h2 web consloe。当然这是默认的，如果你不想在启动程序时启动h2 web consloe，那么就设置为false。#Actuator的健康检查开启所有包括health，info，metrics等management: endpoints: web: exposure: include: &quot;*&quot; #开启health端点详细检查 endpoint: health: show-details: alwayslogging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE 根据配置在resources目录下，新增db文件夹，下面新增schema.sql和data.sql文件，内容分别如下12345drop table movie if exists;create table movie (id bigint generated by default as identity ,movie_name varchar(40),score decimal(10,2),primary key (id));insert into movie (id,movie_name,score) values (1,&apos;肖申克的救赎&apos;,100.00);insert into movie (id,movie_name,score) values (2,&apos;这个杀手不太冷&apos;,101.00); 在pom中添加依赖druid12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 在主程序平级目录新增db目录，新增DataSourceBean.java和DatasourceConf.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@Configuration@Component@Datapublic class DataSourceBean &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DataSourceBean.class); @Autowired DatasourceConf datasourceConf; @Bean public DataSource getDataSource() &#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(datasourceConf.getUrl()); datasource.setUsername(datasourceConf.getUsername()); datasource.setPassword(datasourceConf.getPassword()); datasource.setDriverClassName(datasourceConf.getDriverClassName()); //configuration datasource.setInitialSize(datasourceConf.getInitialSize()); datasource.setMinIdle(datasourceConf.getMinIdle()); datasource.setMaxActive(datasourceConf.getMaxActive()); datasource.setMaxWait(datasourceConf.getMaxWait()); datasource.setTimeBetweenEvictionRunsMillis(datasourceConf.getTimeBetweenEvictionRunsMillis()); datasource.setMinEvictableIdleTimeMillis(datasourceConf.getMinEvictableIdleTimeMillis()); datasource.setValidationQuery(datasourceConf.getValidationQuery()); datasource.setTestWhileIdle(datasourceConf.getTestWhileIdle()); datasource.setTestOnBorrow(datasourceConf.getTestOnBorrow()); datasource.setTestOnReturn(datasourceConf.getTestOnReturn()); datasource.setPoolPreparedStatements(datasourceConf.getPoolPreparedStatements()); datasource.setMaxPoolPreparedStatementPerConnectionSize(datasourceConf.getMaxPoolPreparedStatementPerConnectionSize()); datasource.setUseGlobalDataSourceStat(datasourceConf.getUseGlobalDataSourceStat()); try &#123; datasource.setFilters(datasourceConf.getFilters()); &#125; catch (SQLException e) &#123; LOGGER.error(&quot;druid configuration initialization filter: &quot; + e); &#125; datasource.setConnectionProperties(datasourceConf.getConnectionProperties()); return datasource; &#125; /** * 配置监控服务器 * * @return 返回监控注册的servlet对象 */ @Bean public ServletRegistrationBean statViewServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); // 添加IP白名单 servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;192.168.14.32,127.0.0.1&quot;); // 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高 servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;192.168.14.32&quot;); // 添加控制台管理用户 servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;druid&quot;); servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;); // 是否能够重置数据 servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;); return servletRegistrationBean; &#125; /** * 配置服务过滤器 * * @return 返回过滤器配置对象 */ @Bean public FilterRegistrationBean statFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); // 添加过滤规则 filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); // 忽略过滤格式 filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&quot;); return filterRegistrationBean; &#125;&#125;@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)@Component@Datapublic class DatasourceConf &#123; private String url; private String username; private String password; private String driverClassName; private int initialSize; private int minIdle; private int maxActive; private int maxWait; private int timeBetweenEvictionRunsMillis; private int minEvictableIdleTimeMillis; private String validationQuery; private Boolean testWhileIdle; private Boolean testOnBorrow; private Boolean testOnReturn; private Boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private String filters; private String connectionProperties; private Boolean useGlobalDataSourceStat;&#125; 重新启动主程序，此时会报一个小错，具体原因是由于druid开启了如下配置，当数据库为h2并且需要执行新增表操作时，sql统计分析会合并异常，具体看github上面的issue12# 配置监控统计拦截的filters，去掉后监控界面sql无法统计filters: stat 检查1.查看h2 ui,是否user表和数据是否写入 http://localhost:1016/h2-console/2.查看druid监控页面 http://127.0.0.1:1016/druid/sql.html 集成jooq generate工具具体教程可见springboot集成jooq 扩展 这里和user有一些不同的是，我将h2的数据库类型改成了内存，结果jooq-codegen-maven无法生成1234567&lt;!-- JDBC connection parameters --&gt;&lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:mem:test&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt;&lt;/jdbc&gt; 需要改成文件类型1234567&lt;!-- JDBC connection parameters --&gt;&lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:~/testmovie&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt;&lt;/jdbc&gt; 因为h2选择的是内存数据库，不管我是否将h2数据库开启(程序运行或不运行),然后执行jooq generate,都无法生成如果我将h2类型改为file,那么这个时候不能运行源程序，才能执行jooq generate，否则执行jooq generate的时候会报错数据库使用中 扩展在maven package时，由于集成了jooq generate工具，会执行一遍，这样如果自己修改了相关类会被还原，所以在打包时希望不执行相关驱动可以加如下配置 放在pom驱动配置的configuration标签内20181030更新:注意这个标签添加之后，无论编译打包甚至直接运行这个插件都不再生成相关东西，如果你现在需要重新运行一遍，请先提交或者保存你做过的修改，然后注释掉这个，运行完之后再加上，然后再将你做的修改重新添加回来12&lt;!-- install 跳过 --&gt;&lt;skip&gt;true&lt;/skip&gt;在打包的过程中，执行了springboot中的一些test，当从consul上远程读取yml配置时爆了如下错，忽略测试打包成功后，启动工程仍然报错，然而idea中自己run的时候却没有报错对比了相关命令远程yml配置中含有中文，务必在使用java -Dfile.encoding=UTF-8 -jar .\consul-movie-0.0.1-SNAPSHOT.jar指定utf8编码不然打包会失败，启动失败，会报上面的错https://github.com/jOOQ/jOOQ/blob/master/jOOQ-examples/jOOQ-spring-example/pom.xml]]></content>
      <categories>
        <category>java</category>
        <category>微服务</category>
        <category>springcloud</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jooq</tag>
        <tag>springcloud</tag>
        <tag>h2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud集成feign]]></title>
    <url>%2F2018%2F10%2F29%2Fspringcloud%E9%9B%86%E6%88%90feign%2F</url>
    <content type="text"><![CDATA[前言Feign是声明式、模板化的HTTP客户端，可以更加快捷优雅的调用HTTP API。在部分场景下和Ribbon类似，都是进行数据的请求处理，但是在请求参数使用实体类的时候显然更加方便，同时还支持安全性、授权控制等。Feign是集成了Ribbon的，也就是说如果引入了Feign，那么Ribbon的功能也能使用，比如修改负载均衡策略等。 目的1.springcloud Finchley.SR2版本2.springboot 版本2.0.6.RELEASE以consul为服务发现和配置中心的前提下，集成一个针对springcloud编写用户微服务的用户消费服务 正文初始化工程方法跟springcloud集成consul中前期准备工程一般，勾选下列依赖如果不是上述方法初始化，添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在resources文件夹下新增bootstrap.yml文件，写入以下内容123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1020spring: application: #项目名称 name: consul-feign cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: consul-feign #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.150:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 添加controller类和feign接口这里的user类就是springcloud编写用户微服务中jooq-codegen-maven3.10.8生成的实体对象所以最好是将这些实体模块化，这样在共同需要的地方引用即可，不用像我这样图简便就直接复制过来1234567891011121314151617181920@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired UserFeignClient userFeignClient; @RequestMapping(value = &quot;/getAll&quot;,method = RequestMethod.GET) public List&lt;User&gt; getAll()&#123; return userFeignClient.getAllUser(); &#125;&#125;@FeignClient(name = &quot;consul-user&quot;)public interface UserFeignClient &#123; @RequestMapping(value = &quot;/user/getAll&quot;,method = RequestMethod.GET) List&lt;User&gt; getAllUser();&#125; 20181030更新:get多参数写法 12直接写Long id或者直接是User user这种对象，feign依然会用post方式调用，所以会报错接口不支持需要用@RequestParam(&quot;id&quot;) Long id，或者@RequestParam Map&lt;String,Object&gt; map 最终的工程结构 修改主类主类上添加@EnableFeignClients注解，否则报错找不到UserFeignClient 集成健康检查和hystrix添加依赖1234567891011121314健康检查需加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;hystrix需加&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 远程配置添加健康检查详细监控以及支持hystrix12345678910111213#Actuator的健康检查开启所有包括health，info，metrics等management: endpoints: web: exposure: include: &quot;*&quot; #开启health端点详细检查 endpoint: health: show-details: alwaysfeign: hystrix: enabled: true 修改主类 主类上添加@EnableHystrix注解，否则没有/actuator/hystrix.stream信息，另外上面的配置需要打开，不然没数据]]></content>
      <categories>
        <category>java</category>
        <category>springcloud</category>
        <category>feign</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud集成网关ZUUL]]></title>
    <url>%2F2018%2F10%2F29%2Fspringcloud%E9%9B%86%E6%88%90%E7%BD%91%E5%85%B3ZUUL%2F</url>
    <content type="text"><![CDATA[前言Routing in an integral part of a microservice architecture. For example, / may be mapped to your web application, /api/users is mapped to the user service and /api/shop is mapped to the shop service. Zuul is a JVM based router and server side load balancer by Netflix.路由在微服务架构的一个组成部分。 例如，/可以映射到您的Web应用程序，/api/users映射到用户服务，并且/api/shop映射到商店服务。 Zuul是Netflix的基于JVM的路由器和服务器端负载均衡器。其功能包括12345678910验证见解压力测试金丝雀测试动态路由服务迁移减载安全静态响应处理主动/主动流量管理 Zuul的规则引擎允许规则和过滤器基本上用任何JVM语言编写，内置支持Java和Groovy 目的1.springcloud Finchley.SR2版本2.springboot 版本2.0.6.RELEASE以consul为服务发现和配置中心的前提下，集成一个zuul网关服务 正文初始化工程方法跟springcloud集成consul中前期准备工程一般，勾选下列依赖 20181029更新:上面不用勾选hystrix,下面也说明了zuul中已经集成了在resources文件夹下新增bootstrap.yml文件，写入以下内容123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1050spring: application: #项目名称 name: consul-zuul cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: consul-zuul #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.150:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 在远程配置中心上添加如下配置123456789101112131415zuul: routes: user: # 可以随便写，在zuul上面唯一即可；当这里的值 = service-id时，service-id可以不写。 path: /api/user/** # 想要映射到的路径 service-id: consul-user # consul中的service-name#Actuator的健康检查开启所有包括health，info，metrics等management: endpoints: web: exposure: include: &quot;*&quot; #开启health端点详细检查 endpoint: health: show-details: always 修改主类，在主类上加上@EnableZuulProxy注解，这样就完成了 扩展由于zuul已经集成hystrix，所以当打开详细健康检查时可以看到hystrix已经打开同时查看 http://localhost:1050/actuator/hystrix.stream 注意当没有接口调用时，会显示一直ping,需要调用一个接口，这个页面数据是实时刷新的 参考资料1.自定义zuul过滤器2.zuul比较详细的说明3.springcloud+zuul+hystrix]]></content>
      <categories>
        <category>java</category>
        <category>springcloud</category>
        <category>zuul</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成jooq]]></title>
    <url>%2F2018%2F10%2F26%2Fspringboot%E9%9B%86%E6%88%90jooq%2F</url>
    <content type="text"><![CDATA[前言说明一下springboot2.0.6.RELEASE集成jooq3.10.8以及jooq-codegen-maven3.10.8 目的简单说明一下jooq的集成和用法 正文初始化工程idea初始化工程方法可以参见springcloud编写用户微服务 h2以h2为梨子说明一下添加依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jooq&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 扩展这种不需要写版本的是因为父工程为springboot或者用下面那种写法123456789101112131415161718&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;或者&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;添加驱动工具12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;plugin&gt; &lt;!-- Specify the maven code generator plugin --&gt; &lt;!-- Use org.jooq for the Open Source Edition org.jooq.pro for commercial editions, org.jooq.pro-java-6 for commercial editions with Java 6 support, org.jooq.trial for the free trial edition Note: Only the Open Source Edition is hosted on Maven Central. Import the others manually from your distribution --&gt; &lt;groupId&gt;org.jooq&lt;/groupId&gt; &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt; &lt;!-- The plugin should hook into the generate goal --&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!-- Manage the plugin&apos;s dependency. In this example, we&apos;ll use a PostgreSQL database --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.197&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Specify the plugin configuration. The configuration format is the same as for the standalone code generator --&gt; &lt;configuration&gt; &lt;!-- install 跳过 --&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;!-- JDBC connection parameters --&gt; &lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:~/testuser&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/jdbc&gt; &lt;!-- Generator parameters --&gt; &lt;generator&gt; &lt;database&gt; &lt;name&gt;org.jooq.util.h2.H2Database&lt;/name&gt; &lt;includes&gt;.*&lt;/includes&gt; &lt;excludes&gt;&lt;/excludes&gt; &lt;!-- In case your database supports catalogs, e.g. SQL Server: &lt;inputCatalog&gt;public&lt;/inputCatalog&gt; --&gt; &lt;inputSchema&gt;PUBLIC&lt;/inputSchema&gt; &lt;/database&gt; &lt;generate&gt; &lt;instanceFields&gt;true&lt;/instanceFields&gt; &lt;pojos&gt;true&lt;/pojos&gt; &lt;daos&gt;true&lt;/daos&gt; &lt;springAnnotations&gt;true&lt;/springAnnotations&gt; &lt;/generate&gt; &lt;target&gt; &lt;packageName&gt;com.springcloud.consuluser.dao&lt;/packageName&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;/target&gt; &lt;/generator&gt; &lt;/configuration&gt;&lt;/plugin&gt; 扩展1.这是以h2作为梨子，如果要用mysql的话差不过需要修改相关位置2.maven package打包忽略插件 放在pom驱动配置的configuration标签内20181030更新:注意这个标签添加之后，无论编译打包甚至直接运行这个插件都不再生成相关东西，如果你现在需要重新运行一遍，请先提交或者保存你做过的修改，然后注释掉这个，运行完之后再加上，然后再将你做的修改重新添加回来12&lt;!-- install 跳过 --&gt;&lt;skip&gt;true&lt;/skip&gt; 3.需要生成相关dao和实体，添加如下配置123456&lt;generate&gt; &lt;instanceFields&gt;true&lt;/instanceFields&gt; &lt;pojos&gt;true&lt;/pojos&gt; &lt;daos&gt;true&lt;/daos&gt; &lt;springAnnotations&gt;true&lt;/springAnnotations&gt;&lt;/generate&gt; 4.20181030更新:当h2的数据库类型为内存时，结果jooq-codegen-maven无法生成1234567&lt;!-- JDBC connection parameters --&gt;&lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:mem:test&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt;&lt;/jdbc&gt; 需要改成文件类型1234567&lt;!-- JDBC connection parameters --&gt;&lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:~/testmovie&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt;&lt;/jdbc&gt; jooq-codegen-maven以上配置生成的目录结构如下yml配置文件添加相关配置123456789101112131415161718192021222324252627282930313233343536373839404142spring: datasource: #url: jdbc:h2:mem:test #url: jdbc:h2:file:~/.h2/testdb url: jdbc:h2:~/testuser driverClassName: org.h2.Driver username: sa password: 123456 platform: h2 schema: classpath:db/schema.sql data: classpath:db/data.sql initialization-mode: always #springboot2.0加上上述sql才会执行 # 下面为druid连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 minIdle: 3 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select &apos;x&apos; testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计 filters: stat # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true h2: console: settings: web-allow-others: true #进行该配置后，h2 web consloe就可以在远程访问了。否则只能在本机访问。 path: /h2-console #进行该配置，你就可以通过YOUR_URL/h2-console访问h2 web consloe。YOUR_URL是你程序的访问URl。 enabled: true #进行该配置，程序开启时就会启动h2 web consloe。当然这是默认的，如果你不想在启动程序时启动h2 web consloe，那么就设置为false。 扩展1.上面的配置中添加initialization-mode之后才会初始化schema.sql和data.sql2.initialization-mode配置之后的是druid的补充配置，需结合java程序手动初始化或者添加spring.datasource.type=com.alibaba.druid.pool.DruidDataSource自动初始化，不过这种初始化之前我的druid监控页面无法打开3.h2的控制页面配置如上，如果不加无法访问4.集成druid,详情见springboot集成druid 参考资料java api doc jooq-codegen-maven其他配置 jooq官方example]]></content>
      <categories>
        <category>java</category>
        <category>springboot2</category>
        <category>jooq</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot2</tag>
        <tag>jooq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成druid]]></title>
    <url>%2F2018%2F10%2F26%2Fspringboot%E9%9B%86%E6%88%90druid%2F</url>
    <content type="text"><![CDATA[前言Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能 目的springboot2.0.6.RELEASE集成druid1.1.10 正文添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 添加配置123456789101112131415161718192021222324252627282930313233343536spring: datasource: #url: jdbc:h2:mem:test #url: jdbc:h2:file:~/.h2/testdb url: jdbc:h2:~/testuser driverClassName: org.h2.Driver username: sa password: 123456 platform: h2 schema: classpath:db/schema.sql data: classpath:db/data.sql initialization-mode: always #springboot2.0加上上述sql才会执行 # 下面为druid连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 minIdle: 3 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select &apos;x&apos; testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计 filters: stat # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true 初始化datasource1.添加spring.datasource.type=com.alibaba.druid.pool.DruidDataSource自动初始化，不过这种初始化之前我的druid监控页面无法打开2.利用java程序手动初始化在java源码，springboot主程序的所在目录的子目录下，添加如下两个文件DataSourceBean.java和DatasourceConf.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)@Component@Datapublic class DatasourceConf &#123; private String url; private String username; private String password; private String driverClassName; private int initialSize; private int minIdle; private int maxActive; private int maxWait; private int timeBetweenEvictionRunsMillis; private int minEvictableIdleTimeMillis; private String validationQuery; private Boolean testWhileIdle; private Boolean testOnBorrow; private Boolean testOnReturn; private Boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private String filters; private String connectionProperties; private Boolean useGlobalDataSourceStat;&#125;@Configuration@Component@Datapublic class DataSourceBean &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DataSourceBean.class); @Autowired DatasourceConf datasourceConf; @Bean public DataSource getDataSource() &#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(datasourceConf.getUrl()); datasource.setUsername(datasourceConf.getUsername()); datasource.setPassword(datasourceConf.getPassword()); datasource.setDriverClassName(datasourceConf.getDriverClassName()); //configuration datasource.setInitialSize(datasourceConf.getInitialSize()); datasource.setMinIdle(datasourceConf.getMinIdle()); datasource.setMaxActive(datasourceConf.getMaxActive()); datasource.setMaxWait(datasourceConf.getMaxWait()); datasource.setTimeBetweenEvictionRunsMillis(datasourceConf.getTimeBetweenEvictionRunsMillis()); datasource.setMinEvictableIdleTimeMillis(datasourceConf.getMinEvictableIdleTimeMillis()); datasource.setValidationQuery(datasourceConf.getValidationQuery()); datasource.setTestWhileIdle(datasourceConf.getTestWhileIdle()); datasource.setTestOnBorrow(datasourceConf.getTestOnBorrow()); datasource.setTestOnReturn(datasourceConf.getTestOnReturn()); datasource.setPoolPreparedStatements(datasourceConf.getPoolPreparedStatements()); datasource.setMaxPoolPreparedStatementPerConnectionSize(datasourceConf.getMaxPoolPreparedStatementPerConnectionSize()); datasource.setUseGlobalDataSourceStat(datasourceConf.getUseGlobalDataSourceStat()); try &#123; datasource.setFilters(datasourceConf.getFilters()); &#125; catch (SQLException e) &#123; LOGGER.error(&quot;druid configuration initialization filter: &quot; + e); &#125; datasource.setConnectionProperties(datasourceConf.getConnectionProperties()); return datasource; &#125; /** * 配置监控服务器 * * @return 返回监控注册的servlet对象 */ @Bean public ServletRegistrationBean statViewServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); // 添加IP白名单 servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;192.168.14.32,127.0.0.1&quot;); // 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高 servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;192.168.14.32&quot;); // 添加控制台管理用户 servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;druid&quot;); servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;); // 是否能够重置数据 servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;); return servletRegistrationBean; &#125; /** * 配置服务过滤器 * * @return 返回过滤器配置对象 */ @Bean public FilterRegistrationBean statFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); // 添加过滤规则 filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); // 忽略过滤格式 filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&quot;); return filterRegistrationBean; &#125;&#125; 参考资料Druid 介绍及配置]]></content>
      <categories>
        <category>java</category>
        <category>springboot2</category>
        <category>druid</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot2</tag>
        <tag>druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud编写用户微服务]]></title>
    <url>%2F2018%2F10%2F26%2Fspringcloud%E7%BC%96%E5%86%99%E7%94%A8%E6%88%B7%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[前言1.springcloud Finchley.SR2版本2.springboot 版本2.0.6.RELEASE3.h24.jooq5.consul搭建一个用户微服务 目的利用idea快速搭建一个springcloud集成上述功能的微服务，可以查询用户 正文初始化工程方法跟springcloud集成consul中前期准备工程一般，勾选下列依赖在resources文件夹下新增bootstrap.yml文件，写入以下内容123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1016spring: application: #项目名称 name: consul-user cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: consul-user #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.101:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 启动主工程,查看consul ui发现程序正常注册 如果程序未能正常注册，查看程序是否正常启动或者这里的ip需要写成程序所在机器的ip,consul集群所在的机器能够访问 初始化H2数据库由于已经使用了consul作为配置中心,直接在consul配置界面新增如下配置启动之后发现datasource循环依赖这时候决定手动初始化datasource,同时集成第三方数据库连接池进来，详情springboot集成druid此时consul上的配置如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647spring: datasource: url: jdbc:h2:mem:test #内存 #url: jdbc:h2:file:~/.h2/testdb #文件 driverClassName: org.h2.Driver username: sa password: 123456 platform: h2 schema: classpath:db/schema.sql data: classpath:db/data.sql initialization-mode: always #springboot2.0加上上述sql才会执行 # 下面为druid连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 minIdle: 3 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select &apos;x&apos; testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计 filters: stat # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true h2: console: settings: web-allow-others: true #进行该配置后，h2 web consloe就可以在远程访问了。否则只能在本机访问。 path: /h2-console #进行该配置，你就可以通过YOUR_URL/h2-console访问h2 web consloe。YOUR_URL是你程序的访问URl。 enabled: true #进行该配置，程序开启时就会启动h2 web consloe。当然这是默认的，如果你不想在启动程序时启动h2 web consloe，那么就设置为false。logging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE 根据配置在resources目录下，新增db文件夹，下面新增schema.sql和data.sql文件，内容分别如下12345drop table user if exists;create table user (id bigint generated by default as identity ,username varchar(40),name varchar(20),age int(3),balance decimal(10,2),primary key (id));insert into user (id,username,name,age,balance) values (1,&apos;admin&apos;,&apos;zb&apos;,20,100.00);insert into user (id,username,name,age,balance) values (2,&apos;liuman&apos;,&apos;柳曼&apos;,20,101.00); 在pom中添加依赖druid12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 在主程序平级目录新增db目录，新增DataSourceBean.java和DatasourceConf.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@Configuration@Component@Datapublic class DataSourceBean &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DataSourceBean.class); @Autowired DatasourceConf datasourceConf; @Bean public DataSource getDataSource() &#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(datasourceConf.getUrl()); datasource.setUsername(datasourceConf.getUsername()); datasource.setPassword(datasourceConf.getPassword()); datasource.setDriverClassName(datasourceConf.getDriverClassName()); //configuration datasource.setInitialSize(datasourceConf.getInitialSize()); datasource.setMinIdle(datasourceConf.getMinIdle()); datasource.setMaxActive(datasourceConf.getMaxActive()); datasource.setMaxWait(datasourceConf.getMaxWait()); datasource.setTimeBetweenEvictionRunsMillis(datasourceConf.getTimeBetweenEvictionRunsMillis()); datasource.setMinEvictableIdleTimeMillis(datasourceConf.getMinEvictableIdleTimeMillis()); datasource.setValidationQuery(datasourceConf.getValidationQuery()); datasource.setTestWhileIdle(datasourceConf.getTestWhileIdle()); datasource.setTestOnBorrow(datasourceConf.getTestOnBorrow()); datasource.setTestOnReturn(datasourceConf.getTestOnReturn()); datasource.setPoolPreparedStatements(datasourceConf.getPoolPreparedStatements()); datasource.setMaxPoolPreparedStatementPerConnectionSize(datasourceConf.getMaxPoolPreparedStatementPerConnectionSize()); datasource.setUseGlobalDataSourceStat(datasourceConf.getUseGlobalDataSourceStat()); try &#123; datasource.setFilters(datasourceConf.getFilters()); &#125; catch (SQLException e) &#123; LOGGER.error(&quot;druid configuration initialization filter: &quot; + e); &#125; datasource.setConnectionProperties(datasourceConf.getConnectionProperties()); return datasource; &#125; /** * 配置监控服务器 * * @return 返回监控注册的servlet对象 */ @Bean public ServletRegistrationBean statViewServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); // 添加IP白名单 servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;192.168.14.32,127.0.0.1&quot;); // 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高 servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;192.168.14.32&quot;); // 添加控制台管理用户 servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;druid&quot;); servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;); // 是否能够重置数据 servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;); return servletRegistrationBean; &#125; /** * 配置服务过滤器 * * @return 返回过滤器配置对象 */ @Bean public FilterRegistrationBean statFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); // 添加过滤规则 filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); // 忽略过滤格式 filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&quot;); return filterRegistrationBean; &#125;&#125;@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)@Component@Datapublic class DatasourceConf &#123; private String url; private String username; private String password; private String driverClassName; private int initialSize; private int minIdle; private int maxActive; private int maxWait; private int timeBetweenEvictionRunsMillis; private int minEvictableIdleTimeMillis; private String validationQuery; private Boolean testWhileIdle; private Boolean testOnBorrow; private Boolean testOnReturn; private Boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private String filters; private String connectionProperties; private Boolean useGlobalDataSourceStat;&#125; 重新启动主程序，此时会报一个小错，具体原因是由于druid开启了如下配置，当数据库为h2并且需要执行新增表操作时，sql统计分析会合并异常，具体看github上面的issue12# 配置监控统计拦截的filters，去掉后监控界面sql无法统计filters: stat 检查1.查看h2 ui,是否user表和数据是否写入 http://localhost:1016/h2-console/2.查看druid监控页面 http://127.0.0.1:1016/druid/sql.html 集成jooq generate工具具体教程可见springboot集成jooq 扩展在maven package时，由于集成了jooq generate工具，会执行一遍，这样如果自己修改了相关类会被还原，所以在打包时希望不执行相关驱动可以加如下配置 放在pom驱动配置的configuration标签内20181030更新:注意这个标签添加之后，无论编译打包甚至直接运行这个插件都不再生成相关东西，如果你现在需要重新运行一遍，请先提交或者保存你做过的修改，然后注释掉这个，运行完之后再加上，然后再将你做的修改重新添加回来12&lt;!-- install 跳过 --&gt;&lt;skip&gt;true&lt;/skip&gt;在打包的过程中，执行了springboot中的一些test，当从consul上远程读取yml配置时爆了如下错，忽略测试打包成功后，启动工程仍然报错，然而idea中自己run的时候却没有报错对比了相关命令远程yml配置中含有中文，务必在使用java -Dfile.encoding=UTF-8 -jar .\consul-user-0.0.1-SNAPSHOT.jar指定utf8编码不然打包会失败，启动失败，会报上面的错https://github.com/jOOQ/jOOQ/blob/master/jOOQ-examples/jOOQ-spring-example/pom.xml]]></content>
      <categories>
        <category>java</category>
        <category>微服务</category>
        <category>springcloud</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jooq</tag>
        <tag>springcloud</tag>
        <tag>h2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud集成consul]]></title>
    <url>%2F2018%2F10%2F23%2Fspringcloud%E9%9B%86%E6%88%90consul%2F</url>
    <content type="text"><![CDATA[前言1.springcloud Finchley.SR2版本2.springboot 版本2.0.6.RELEASE集成consul作为配置中心和服务发现中心，同时开启健康检查 目的利用idea快速搭建一个springcloud集成上述功能的微服务 正文利用idea新建工程新建springboot maven工程设置项目信息勾选自动配置勾选consul配置中心勾选consul服务发现中心完成 新建bootstrap.yml文件,添加如下内容，并启动主程序123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1015spring: application: #项目名称 name: springcloud-consul cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: springcloud-consul #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.101:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 启动主程序,发现报错添加依赖1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 重新启动正常访问健康检查端点 http://ip:port/actuator/health 在consul ui上查看访问consul ui http://localhost:18500/ consul 作为配置中心访问consul ui 添加配置信息12app: port: 3232 新增conf目录，新增如下代码12345678910111213141516@Component@ConfigurationProperties(prefix = &quot;app&quot;)@Datapublic class AppConf &#123; private static final Logger LOGGER = LoggerFactory.getLogger(AppConf.class); private int port; @PostConstruct public void printConf()&#123; LOGGER.info(&quot;加载配置port:[&#123;&#125;]&quot;,port); &#125;&#125;重新启动主程序 附加工程pom1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springcloud&lt;/groupId&gt; &lt;artifactId&gt;consul1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;consul1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 参考资料springcloud-consul中文文档]]></content>
      <categories>
        <category>java</category>
        <category>微服务</category>
        <category>springcloud</category>
        <category>consul</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>consul</tag>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows上安装docker-ce]]></title>
    <url>%2F2018%2F10%2F21%2Fwindows%E4%B8%8A%E5%AE%89%E8%A3%85docker-ce%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>windows</category>
        <category>docker</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>安装</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose搭建consul集群]]></title>
    <url>%2F2018%2F10%2F21%2Fdocker-compose%E6%90%AD%E5%BB%BAconsul%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>docker-compose</category>
        <category>consul集群</category>
      </categories>
      <tags>
        <tag>docker-compose</tag>
        <tag>consul集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot+Aop+自定义注解实现日志记录]]></title>
    <url>%2F2018%2F10%2F21%2Fspringboot-Aop-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言 AOP（Aspect Orient Programming），也就是面向方面编程，作为面向对象编程的一种补充，专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在Java EE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理两大类，静态代理以AspectJ为代表；而动态代理则以Spring AOP为代表 目的简单说明一下AspectJ，另外实现一个springboot+Aop+自定义注解实现日志记录的梨子 正文AspectJAspectJ 是一个基于 Java 语言的 AOP 框架，提供了强大的 AOP 功能，其他很多 AOP 框架都借鉴或采纳其中的一些思想。AspectJ 是 Java 语言的一个 AOP 实现，其主要包括两个部分：第一个部分定义了如何表达、定义 AOP 编程中的语法规范，通过这套语言规范，我们可以方便地用 AOP 来解决 Java 语言中存在的交叉关注点问题；另一个部分是工具部分，包括编译器、调试工具等。AspectJ 是编译期增强的框架，需要遵从相关语法然后用他的工具编译织入 springboot aop添加依赖123456789101112&lt;!-- AOP依赖模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667自定义注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AnalysisActuator &#123; String note() default &quot;&quot;;&#125;定义切面@Aspect@Componentpublic class AnalysisActuatorAspect &#123; final static Logger log = LoggerFactory.getLogger(AnalysisActuatorAspect.class); ThreadLocal&lt;Long&gt; beginTime = new ThreadLocal&lt;&gt;(); @Pointcut(&quot;@annotation(analysisActuator)&quot;) public void serviceStatistics(AnalysisActuator analysisActuator) &#123; &#125; @Before(&quot;serviceStatistics(analysisActuator)&quot;) public void doBefore(JoinPoint joinPoint, AnalysisActuator analysisActuator) &#123; // 记录请求到达时间 beginTime.set(System.currentTimeMillis()); &#125; @After(&quot;serviceStatistics(analysisActuator)&quot;) public void doAfter(AnalysisActuator analysisActuator) &#123; log.info(&quot;statistic time:&#123;&#125;, note:&#123;&#125;&quot;, System.currentTimeMillis() - beginTime.get(), analysisActuator.note()); &#125;&#125;服务改写@Servicepublic class PersonServiceForAopImpl implements PersonService &#123; @AnalysisActuator(note = &quot;[PersonServiceForAopImpl]插入&quot;) @Override public int insert(Object obj) &#123; System.out.println(&quot;成功插入一个person&quot;); return 1; &#125; @AnalysisActuator(note = &quot;[PersonServiceForAopImpl]更新&quot;) @Override public int update(Object obj) &#123; System.out.println(&quot;成功更新一个person&quot;); return 1; &#125;&#125;测试服务@RunWith(SpringRunner.class)@SpringBootTestpublic class TestPersonServiceForAopImpl &#123; @Qualifier(&quot;personServiceForAopImpl&quot;) @Autowired PersonService personService; @Test public void testInsert()&#123; personService.insert(new Object()); &#125;&#125; 执行结果 参考资料1.Spring AOP实现原理与CGLIB应用2.使用Spring Boot的AOP处理自定义注解]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
        <category>aop</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>aop</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CGLib代理]]></title>
    <url>%2F2018%2F10%2F21%2FCGLib%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言java动态代理这篇博客介绍了java的动态代理，那么这里同样不得不介绍一下CGLib代理。JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理.cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理 目的简单介绍一下cglib的代理应用 正文同样用java动态代理的那个梨子 cglib代理添加依赖12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt;&lt;/dependency&gt;12345678910111213141516171819202122232425262728293031public class CglibProxyInterceptor implements MethodInterceptor &#123; //通过Enhancer 创建代理对象 private Enhancer enhancer = new Enhancer(); //通过Class对象获取代理对象 public &lt;T&gt; T getProxy(Class c)&#123; //设置创建子类的类 enhancer.setSuperclass(c); enhancer.setCallback(this); return (T)enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;CglibProxyInterceptor 代理方法&quot;); return methodProxy.invokeSuper(o,objects); &#125; public static void main(String[] args) &#123; //原来的调用方式 PersonService personService = new PersonServiceImpl(); personService.insert(new Object()); personService.update(new Object()); System.out.println(&quot;**********************&quot;); CglibProxyInterceptor proxy = new CglibProxyInterceptor(); PersonService personServiceProxy = proxy.getProxy(PersonServiceImpl.class); personServiceProxy.insert(new Object()); personServiceProxy.update(new Object()); &#125;&#125;执行结果与java动态代理相比123456相同点: 1.两个都新增了一个代理类，代理的类限制不大,扩展性很高 2.两种方式都不需要修改接口类以及实现类，只需要修改调用的地方即可，利用代理类调用不同点: 1.jdk动态代理需要对接口代理，cglib对非final修辞的类都可以代理 2.cglib是第三方包,需要添加依赖]]></content>
      <categories>
        <category>java</category>
        <category>CGLib</category>
        <category>代理</category>
      </categories>
      <tags>
        <tag>CGLib</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java动态代理]]></title>
    <url>%2F2018%2F10%2F21%2Fjava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言java反射基础用法这边博客讲解了java反射的一些基础用法，那么动态代理就是利用反射实现的一个高级用法 目的简单介绍一下动态代理的用法，JDK提供的代理只能针对接口做代理,我们有更强大的代理CGLib代理 正文假设有个personservice服务类接口以及实现类，现如今需要在尽可能少量修改代码的前提下，让原来的方法增加一些其他方法1234567891011121314151617181920212223public interface PersonService &#123; //插入一个person int insert(Object obj); //更新一个person int update(Object obj);&#125;public class PersonServiceImpl implements PersonService &#123; @Override public int insert(Object obj) &#123; System.out.println(&quot;成功插入一个person&quot;); return 1; &#125; @Override public int update(Object obj) &#123; System.out.println(&quot;成功更新一个person&quot;); return 1; &#125;&#125; 静态代理123456789101112131415161718192021222324252627282930313233public class SimplePersonServiceProxy implements PersonService&#123; //被代理接口类 private PersonService personService; public SimplePersonServiceProxy(PersonService personService) &#123; this.personService = personService; &#125; @Override public int insert(Object obj) &#123; System.out.println(&quot;SimplePersonServiceProxy 插入静态代理方法&quot;); return personService.insert(obj); &#125; @Override public int update(Object obj) &#123; System.out.println(&quot;SimplePersonServiceProxy 更新静态代理方法&quot;); return personService.update(obj); &#125; public static void main(String[] args) &#123; //原来的调用方式 PersonService personService = new PersonServiceImpl(); personService.insert(new Object()); personService.update(new Object()); System.out.println(&quot;**********************&quot;); //增加功能的调用方法，原来的PersonService和PersonServiceImpl代码都不需要变 PersonService proxy = new SimplePersonServiceProxy(new PersonServiceImpl()); proxy.insert(new Object()); proxy.update(new Object()); &#125;&#125; 执行结果: 动态代理12345678910111213141516171819202122232425262728public class DynamicProxyHandler implements InvocationHandler &#123; //被代理对象，这里跟静态代理对比，这里的代码扩展性更高，可以是任何对象 private Object object; public DynamicProxyHandler(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;DynamicProxyHandler java动态代理方法&quot;); return method.invoke(object,args); &#125; public static void main(String[] args) &#123; //原来的调用方式 PersonService personService = new PersonServiceImpl(); personService.insert(new Object()); personService.update(new Object()); System.out.println(&quot;**********************&quot;); //增加功能的调用方法，原来的PersonService和PersonServiceImpl代码都不需要变 PersonService proxy = (PersonService) Proxy.newProxyInstance(PersonService.class.getClassLoader(),new Class[]&#123;PersonService.class&#125;,new DynamicProxyHandler(new PersonServiceImpl())); proxy.insert(new Object()); proxy.update(new Object()); &#125;&#125; 执行结果:对比两种方式，我们可以得出结论123456789相同点: 1.两个都新增了一个代理类，并且属性都是代理类，只不过静态代理的属性限制的更大，必须是 代理接口类 2.两种方式都不需要修改接口类以及实现类，只需要修改调用的地方即可，利用代理类调用不同点 1.静态代理需要实现代理接口，并且属性为代理类接口，这说明每个接口都需要实现一个静态代 理类，扩展性不高，正因为如此，其每个代理的类中的方法可以各自写相关的代理方法 2.动态代理类由于其属性为Object,所以可以代理任何接口,扩展性高，不过由于每个方法执行 前的代理方法都是一样的，所以更适合做一些通用的代理]]></content>
      <categories>
        <category>java</category>
        <category>动态代理</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射基础用法]]></title>
    <url>%2F2018%2F10%2F15%2Fjava%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言Java让我们在运行时识别对象和类的信息，主要有2种方式:12传统的RTTI，它假定我们在编译时已经知道了所有的类型信息;反射机制，它允许我们在运行时发现和使用类的信息; 目的简单介绍一下反射的机制和应用. 正文class对象class对象包含了与类有关的信息,是用来创建所有“常规”对象的.每个类都会产生一个对应的Class对象，也就是保存在.class文件。所有类都是在对其第一次使用时，动态加载到JVM的，当程序创建一个对类的静态成员的引用时，就会加载这个类.Class对象仅在需要的时候才会加载，static初始化是在类加载时进行的 扩展1234567891011121314151617181920212223242526272829303132public class TestClass &#123; public static void main(String[] args) &#123; //静态内部类-静态属性 System.out.println(InnerClass.staticName); System.out.println(&quot;**************************&quot;); //静态内部类-普通属性 InnerClass in = new InnerClass(); System.out.println(in.name); System.out.println(&quot;**************************&quot;); //外部类-普通属性 System.out.println(new OutterClass().outterName); System.out.println(&quot;**************************&quot;); //外部类-静态属性 System.out.println(OutterClass.outterStaticName); &#125; static class InnerClass &#123; public static String staticName = &quot;innerStaticName&quot;; public String name = &quot;innerName&quot;; static &#123; System.out.println(&quot;静态内部类静态块&quot;); &#125; public InnerClass() &#123; System.out.println(&quot;静态内部类已经构造好了&quot;); &#125; &#125;&#125;上面代码运行的结果:结论: 说明当第一次引用一个类的静态属性时，该类会加载到jvm中并调用静态块初始化类时会调用相应构造方法，由于该类已经加载到jvm中，所以不会调用静态块第三点同时印证了第二点，第一次初始化某个类时，该类加载到jvm中，首先调用静态块方法，然后调用相应构造方法第四点印证第二点 获取class对象引用的两种方式及区别12使用功能”.class”来创建Class对象的引用使用功能Class.forName(“xxx”) 区别:想在运行时使用类型信息，必须获取对象(比如类Base对象)的Class对象的引用，使用功能Class.forName(“Base”)可以实现该目的，或者使用base.class。注意，有一点很有趣，使用功能”.class”来创建Class对象的引用时，不会自动初始化该Class对象，使用forName()会自动初始化该Class对象。为了使用类而做的准备工作一般有以下3个步骤:123加载：由类加载器完成，找到对应的字节码，创建一个Class对象链接：验证类中的字节码，为静态域分配空间初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块 扩展1234567891011121314151617181920212223242526272829303132333435363738394041public class BaseMain &#123; public static void main(String[] args) throws Exception &#123; //通过obj.class获取class对象的引用 Class clz1 = StaticBase.class; System.out.println(&quot;*********************&quot;); //通过Class.获取class对象的引用--静态内部类 Class clz2 = Class.forName(&quot;com.example.demo.java.reflect.BaseMain$StaticBase&quot;); //通过Class.获取class对象的引用--普通内部类 Class clz3 = Class.forName(&quot;com.example.demo.java.reflect.BaseMain$Base&quot;); System.out.println(&quot;*********************&quot;); //内部类的构造方法获取 clz3也可以换成Base.class Constructor con3 = clz3.getDeclaredConstructor(BaseMain.class); //私有构造需要设置 con3.setAccessible(true); Object obj3 = con3.newInstance(BaseMain.class.newInstance()); &#125; static class StaticBase &#123; static int num = 1; static &#123; System.out.println(&quot;StaticBase 静态块:num = &quot; + num); &#125; &#125; public class BaseParent&#123; public BaseParent() &#123; System.out.println(&quot;父类被构造了&quot;); &#125; &#125; private class Base extends BaseParent&#123; int num = 2; private Base() &#123; System.out.println(&quot;普通内部类被构造了:num = &quot; + num); &#125; &#125;&#125;执行结果:结论123obj.class确实不会初始化类Class.forName会调用静态块初始化子类构造先初始化父类构造 反射获取私有属性和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ReflectDemo &#123; public static void main(String[] args) throws Exception &#123; OutterClass out = new OutterClass(); System.out.println(&quot;***************&quot;); getAllFields(out); System.out.println(&quot;***************&quot;); getAllMethods(out); &#125; /** * 获取一个对象的所有属性 * @param obj */ public static void getAllFields (Object obj) throws Exception&#123; //获取该类包括父类的属性，未注释的表示只有该类的 //Field[] fields = obj.getClass().getFields(); Field[] fields = obj.getClass().getDeclaredFields(); for(Field f : fields)&#123; f.setAccessible(true); System.out.println(&quot;属性-值:&quot;+f.getName()+&quot;-&quot;+f.get(obj)); &#125; &#125; public static void getAllMethods (Object obj) throws Exception &#123; //获取该类包括父类的属性，未注释的表示只有该类的 //Method[] methods = obj.getClass().getMethods(); Method[] methods = obj.getClass().getDeclaredMethods(); for(Method m : methods)&#123; m.setAccessible(true); System.out.println(m+&quot;\n参数个数:&quot;+m.getParameterCount()); switch (m.getParameterCount())&#123; case 0: m.invoke(obj); break; case 1: m.invoke(obj,&quot;hello&quot;); break; default: System.out.println(&quot;参数个数大于1&quot;); &#125; &#125; &#125;&#125; 执行结果:]]></content>
      <categories>
        <category>java</category>
        <category>语法</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>java语法</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp3链式调用]]></title>
    <url>%2F2018%2F10%2F13%2Fokhttp3%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性：1234支持HTTP/2，允许所有同一个主机地址的请求共享同一个socket连接连接池减少请求延时透明的GZIP压缩减少响应数据的大小缓存响应内容，避免一些完全重复的请求 目的介绍一些okhttp3的基本用法 正文获取OkHttpClient客户端12345678//简单获取OkHttpClient client = new OkHttpClient();//设置超时时间private static final OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS) .build(); get请求普通get请求1234567891011121314String url = &quot;https://www.baidu.com/&quot;;OkHttpClient okHttpClient = new OkHttpClient();Request request = new Request.Builder() .url(url) .build();Call call = okHttpClient.newCall(request);try &#123; Response response = call.execute(); if (response.isSuccessful()) &#123; System.out.println(response.body().string()); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 设置header参数可以设置例如Cookie，User-Agent什么的123456Request request = new Request.Builder() .url(url) .header(&quot;键&quot;, &quot;值&quot;) .header(&quot;键&quot;, &quot;值&quot;) ... .build(); post请求普通的表单提交1234567891011121314151617181920String url = &quot;https://www.baidu.com/&quot;;OkHttpClient okHttpClient = new OkHttpClient();RequestBody body = new FormBody.Builder() .add(&quot;键&quot;, &quot;值&quot;) .add(&quot;键&quot;, &quot;值&quot;) .build();Request request = new Request.Builder() .url(url) .post(body) .build();Call call = okHttpClient.newCall(request);try &#123; Response response = call.execute(); System.out.println(response.body().string());&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 参考资料OkHttp3的基本用法 简书 许宏川]]></content>
      <categories>
        <category>java</category>
        <category>http调用客户端</category>
      </categories>
      <tags>
        <tag>http调用客户端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xxl-job-V1.9.1实现jobapi远程调用]]></title>
    <url>%2F2018%2F10%2F12%2Fxxl-job-V1-9-1%E5%AE%9E%E7%8E%B0jobapi%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言xxl-job是一个非常好用的分布式java任务调度框架,目前实际应用中框架建议我们在其管理页面手动新增调度任务,但是由于一些情况,我们更加希望能够通过代码动态添加job,官方在job-core中提供了相关api,位置:com.xxl.job.core.biz.AdminBiz.java但是提供的功能有限,无法满足我们的需求,但是根据后面官方的说法，可以通过修改xxl-jobadmin的源码,实现其部分接口可以绕过登陆来远程调用 目的通过修改xxl-jobadmin的源码,实现其部分接口可以绕过登陆来远程调用:1234567任务列表查询任务新增任务更新任务删除任务暂停任务恢复任务触发 正文下载xxl-job-v1.9.1的源码xxl-job-v1.9.1 下载地址 目前我们用的是v1.9.1的,此版本适合这种方式，如果是后续版本建议看一下官方文档，没准官方给出了更合适的方法 修改源码重新打包准确修改位置为com.xxl.job.admin.controller.JobInfoController中的接口方法上加上@PermessionLimit(limit = false) 测试通过postman调用接口,一个是未修改源码的,请求被登陆拦截修改源码后，调用后通过json方式返回 参考资料1.官方针对远程调用的方法解决]]></content>
      <categories>
        <category>java</category>
        <category>分布式</category>
        <category>任务调度框架</category>
      </categories>
      <tags>
        <tag>xxl-job</tag>
        <tag>分布式java调度框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux上安装docker-compose]]></title>
    <url>%2F2018%2F09%2F10%2Flinux%E4%B8%8A%E5%AE%89%E8%A3%85docker-compose%2F</url>
    <content type="text"><![CDATA[前言linux上安装docker-compose,为了在安装了docker的机器上更加方便的编排容器 目的利用docker-compose快速编排docker容器 正文wget1wget https://github.com/docker/compose/releases/download/1.22.0/docker-compose-Linux-x86_64 如果wget没有安装,利用下面命令安装1yum install wget另外如果wget下载不下来,因为直接从github上下载,国内可能网速并不理想docker-compose v1.22.0 下载提取码:ixnx mv并设置环境变量1234567891011mv docker-compose-Linux-x86_64 docker-composemkdir -p /apps/softs/docker_compose/cd /apps/softs/docker_compose/cp /dev/zkandkafka/docker-compose /apps/softs/docker_compose/chmod +x docker-compose修改环境变量vi /etc/profileDOCKER_COMPOSE_HOME=/apps/softs/docker_compose/PATH=$PATH:$DOCKER_COMPOSE_HOMEexport PATHsource /etc/profile 验证1docker-compose -v 其他docker-compose版本]]></content>
      <categories>
        <category>docker-compose</category>
        <category>docker服务编排工具</category>
      </categories>
      <tags>
        <tag>docker-compose</tag>
        <tag>docker服务编排工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java程序打成docker镜像]]></title>
    <url>%2F2018%2F08%2F25%2Fjava%E7%A8%8B%E5%BA%8F%E6%89%93%E6%88%90docker%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[前言本片教程适合idea+java+maven的环境,另外需要有docker环境,如果windows上没有，可以将程序拷贝到linux上有docker的环境上执行相关操作docker环境安装教程[] 目的将java程序打进docker镜像中,方便docker方式部署 正文mavne添加以下依赖并执行生成Dockerfile在pom文件的bulid中添加如下驱动123456789101112131415161718192021&lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;api&lt;/imageName&gt; &lt;baseImage&gt;java&lt;/baseImage&gt; &lt;maintainer&gt;test@email.com&lt;/maintainer&gt; &lt;workdir&gt;/ROOT&lt;/workdir&gt; &lt;cmd&gt;["java", "-version"]&lt;/cmd&gt; &lt;entryPoint&gt;["java", "-jar", "$&#123;project.build.finalName&#125;.jar"]&lt;/entryPoint&gt; &lt;!-- 这里是复制 jar 包到 docker 容器指定目录配置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/ROOT&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt;&lt;/plugin&gt;执行docker_build之后会自动生成Dockerfile,如果你的windows上有docker,会生成镜像,由于我的机器上没有，因为新版的docker安装到window上有系统限制，详情查看这篇博客[]Dockerfile内容如下123456FROM javaMAINTAINER test@email.comWORKDIR /ROOTADD /ROOT/xxx.jar /ROOT/ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;xxx.jar&quot;]CMD [&quot;java&quot;, &quot;-version&quot;] 转移到linux上有docker环境的机器上开始build修改一下Dockerfile,将配置文件也打入进去,上面驱动也可以改造成通过Dockerfile打包,而不是写到pom中1234567FROM javaMAINTAINER test@email.comWORKDIR /ROOTADD ./xxx.jar /ROOT/ADD ./conf /ROOT/ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;xxx.jar&quot;]CMD [&quot;java&quot;, &quot;-version&quot;]linux上目录结构如下执行build指令1docker build -t job:0814 .终端打印成功截图docker images验证截图]]></content>
      <categories>
        <category>java</category>
        <category>Dockerfile</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>镜像</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker镜像迁移]]></title>
    <url>%2F2018%2F08%2F24%2Fdocker%E9%95%9C%E5%83%8F%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[前言一般正规的做法应该是将自己做好的镜像push到远程仓库去,然后需要的时候从远处仓库拉取.由于目前我还没有建立私有远程仓库所以这篇博客主要是讲手动导出镜像的方法 目的手动导出镜像以便于在其他地方使用 正文查看镜像列表1docker images save导出镜像指令: docker save repository:tag &gt; 自定义导出名字.tar 推荐或者 docker save image_id &gt; 自定义导出名字.tar1docker save webapi:0814 &gt; webapi0814.tar截图: load导入镜像1docker load -qi webapi0814.tar 截图:验证:docker images 查看一下导入情况,这里说明一下,如果之前指令是通过save imageid导出的镜像的话,这里导入的时候仓库和标签名可能为空,推荐save repository:tag导出]]></content>
      <categories>
        <category>docker</category>
        <category>镜像</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>镜像</tag>
        <tag>迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker离线安装包准备]]></title>
    <url>%2F2018%2F08%2F23%2Fdocker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[前言在一台有网络的centos上准备docker-ce.18离线安装包,然后可以根据docker离线安装这篇博客离线安装docker下面的操作都是在有网络的centos7上进行操作的 目的为离线安装docker提供相关依赖和程序包 正文建立本地文件夹1mkdir -p /apps/docker/packages 修改yum源镜像地址先看一下有没有wget ,没有先装一下，在备份1yum install wget备份原来的repo123cd /etc/yum.repos.d/mkdir backupmv ./CentOS-* ./backup/下载阿里的镜像源并应用123wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum clean allyum makecache截图: 下载createrepo软件包及其依赖1repotrack -a x86_64 -p /apps/docker/packages createrepo 如果上诉指令不存在,先安装yum-utils1yum install -y yum-utils截图:再次执行repotrack上面那个指令,开始下载依赖包截图:下载libgudev1和systemd-sysv，是因为centos7.2的libgudev1和systemd-sysv依赖systemd-219-19.el7.x86_64，而docker-ce需要systemd-219-30el7.x86_64.下载 libgudev1和systemd-sysv软件包机器依赖12repotrack -a x86_64 -p /apps/docker/packages libgudev1repotrack -a x86_64 -p /apps/docker/packages systemd-sysv 下载docker-ce及依赖由于你的yum远程仓库可能没有docker-ce的相关依赖,建议之前先执行下面的命令添加阿里的docker仓库镜像1yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo然后下载docker-ce相关依赖1repotrack -a x86_64 -p /apps/docker/packages docker-ce 压缩下载执行下面的命令,将在/apps/docker目录下生成一个docker-ce-18-offline-yum.tgz的包,这个包通过xftp下载后可以在其他地方离线安装docker只要离线的电脑上有yum命令并且是centos7以上的系统12cd /apps/dockertar -zcvf docker-ce-18-offline-yum.tgz /apps/docker/packages]]></content>
      <categories>
        <category>docker</category>
        <category>离线</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>离线</tag>
        <tag>安装包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo在多台电脑之间迁移写作]]></title>
    <url>%2F2018%2F08%2F21%2Fhexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B9%8B%E9%97%B4%E8%BF%81%E7%A7%BB%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言首先根据[]这篇博客将hexo部署到github上,注意最后的效果需是hexo源文件包在远程dev分支下，hexo编译后的静态文件在master目录下。 目的能够方便在不同场合下,或家里,或公司,在不同电脑上随时更新我的blog,而不用手动的拷贝hexo源文件 正文clone1git clone https://github.com/CreamBing/CreamBing.github.io.git 截图(idea)]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>迁移</tag>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker离线安装]]></title>
    <url>%2F2018%2F08%2F21%2Fdocker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>docker</category>
        <category>离线</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>离线</tag>
        <tag>安装</tag>
      </tags>
  </entry>
</search>
