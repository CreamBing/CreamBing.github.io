---
title: 回溯与递归
date: 2019-01-07 20:16:52
tags:
- 算法
- 回溯
categories:
- 算法
- 回溯
comments: true
---
# 前言
最近在leetcode刷题，对于平常不是很清楚的一些数据结构和算法重新回顾和巩固一遍
# 目的
了解回溯和递归的区别，另外弄清楚回溯的特点和应用场景
<!-- more -->

# 正文
## 回溯和递归的区别和联系
```
递归:递归是一种算法结构,函数调用本身,最直接的递归应用就是计算连续数的阶乘，计算规律：n!=(n-1)!*n，还有汉诺塔的实现
回溯:在按某种搜索策略搜索的过程中，当到达某一状态时，继续向前搜索已经确定不会得到正确答案的情况下，可以返回上一搜索状态，沿着新的可能性继续搜索。其求解过程的实质是一个先序遍历一棵“状态树”的过程
```
两者之间的联系:回溯多用递归实现

## 回溯的特点
```
搜索策略:符合递归算法，问题解决可以化为子问题，算法类似，规模减小;
控制策略:当遇到失败的搜索状态，需要返回上一状态，沿另外的路径搜索;
数据结构:一般用数组保存搜索过程中的状态、路径。
```

## 选择回溯的前提
```
选择：对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列
条件：对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回
结束：当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数
```

## 回溯参数的设计
```
必须要有一个临时变量(可以就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是，把每次递归的不同情况传递给递归调用的函数。
可以有一个全局变量，用来存储完整的每个解，一般是个集合容器（也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可）。
最重要的一点，一定要在参数设计中，可以得到结束条件。一个选择是可以传递一个量n，也许是数组的长度，也许是数量，等等。
要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯。
```

<font color="#2ecc71" size="4"><i class="fa fa-spinner fa-spin"></i>扩展</font>
{% link #784 LetterCasePermutation https://leetcode.com/problems/letter-case-permutation/ %}
```java
/**
 * creambing.com Inc.
 * Copyright (c) 2016-2017 All Rights Reserved.
 */


package com.creambing.leetcode.backtracking;

import java.util.LinkedList;
import java.util.List;

/**
 * Class Name:LetterCasePermutation784
 * Description:字母大小写全排列
 *
 * @author Bing
 * @create 2019-01-07  20:52
 * @version v1.0
 */
public class LetterCasePermutation784 {

    public List<String> letterCasePermutation(String S) {
        //全局的结果集合，作为回溯入参，保存完整结果
        List<String> result = new LinkedList<>();
        //开始回溯，这里选用字符数组，方便遍历以及替换字符，同时还可以连接成完整结果
        backtracking(S.toCharArray(), 0, result);
        return result;
    }

    private void backtracking(char[] s, int pos, List<String> result) {
        result.add(new String(s));
        for (int j = pos; j < s.length; j++) {
            char ch = s[j];
            if (Character.isAlphabetic(ch)) {
                s[j] = flip(ch);
                backtracking(s, j+1, result);
                s[j]= ch;
            }
        }
    }

    private char flip(char ch){
        return Character.isUpperCase(ch)? Character.toLowerCase(ch):Character.toUpperCase(ch);
    }

    public static void main(String[] args) {
        String s ="ab14c";
        new LetterCasePermutation784().letterCasePermutation(s).forEach(System.out::println);
    }
}

```
思路根据上面的对于回溯的理解设计参数，我们从最简单的情景来设计程序，假设串是a,那么结果就是a,A,那么这个最简单的逻辑是什么了？先把当前串写入集合中，把第i个字母大小转换(数字不管)就是下面这段,要注意的是:<font color="#eb4d4b">要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯,因此注释的那段很重要，要加上，否则回溯会有问题</font>
```java
public class LetterCasePermutation784 {
    
    private void backtracking(char[] s, int pos, List<String> result) {
            result.add(new String(s));
            for (int j = pos; j < s.length; j++) {
                char ch = s[j];
                if (Character.isAlphabetic(ch)) {
                    s[j] = flip(ch);
                    backtracking(s, j+1, result);
                    //s[j]= ch;
                }
            }
        }
}
```
运行结果截图
{% img /images/algorithm/java/backtracking/784_result.png %}
运行流程分析
{% img /images/algorithm/java/backtracking/LetterCasePermutation784.jpg %}
Runtime: 10 ms, faster than 45.47% of Java online submissions for Letter Case Permutation.
其他需要回溯方法解决的leetcode题目:https://leetcode.com/tag/backtracking/
# 参考资料
1.https://www.jianshu.com/p/4c5ccac18fac 递归2-回溯与递归 偏偏注定要落脚丶
2.https://blog.csdn.net/u014772862/article/details/51789015 回溯和递归区别 繁拾简忆
3.https://blog.csdn.net/sinat_27908213/article/details/80599460 回溯算法超通俗易懂详尽分析和例题 littlelufisher
